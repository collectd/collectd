=encoding UTF-8

=head1 NAME

collectd.conf - Configuration for the system statistics collection daemon B<collectd>

=head1 SYNOPSIS

  BaseDir "/path/to/data/"
  PIDFile "/path/to/pidfile/collectd.pid"
  Server  "123.123.123.123" 12345
  
  LoadPlugin cpu
  LoadPlugin load
  
  <LoadPlugin df>
    Interval 3600
  </LoadPlugin>
  
  LoadPlugin ping
  <Plugin ping>
    Host "example.org"
    Host "provider.net"
  </Plugin>

=head1 DESCRIPTION

This config file controls how the system statistics collection daemon
B<collectd> behaves. The most significant option is B<LoadPlugin>, which
controls which plugins to load. These plugins ultimately define collectd's
behavior.

The syntax of this config file is similar to the config file of the famous
I<Apache> webserver. Each line contains either an option (a key and a list of
one or more values) or a section-start or -end. Empty lines and everything
after a non-quoted hash-symbol (C<#>) is ignored. I<Keys> are unquoted
strings, consisting only of alphanumeric characters and the underscore (C<_>)
character. Keys are handled case insensitive by I<collectd> itself and all
plugins included with it. I<Values> can either be an I<unquoted string>, a
I<quoted string> (enclosed in double-quotes) a I<number> or a I<boolean>
expression. I<Unquoted strings> consist of only alphanumeric characters and
underscores (C<_>) and do not need to be quoted. I<Quoted strings> are
enclosed in double quotes (C<">). You can use the backslash character (C<\>)
to include double quotes as part of the string. I<Numbers> can be specified in
decimal and floating point format (using a dot C<.> as decimal separator),
hexadecimal when using the C<0x> prefix and octal with a leading zero (C<0>).
I<Boolean> values are either B<true> or B<false>.

Lines may be wrapped by using C<\> as the last character before the newline.
This allows long lines to be split into multiple lines. Quoted strings may be
wrapped as well. However, those are treated special in that whitespace at the
beginning of the following lines will be ignored, which allows for nicely
indenting the wrapped lines.

The configuration is read and processed in order, i.e. from top to bottom. So
the plugins are loaded in the order listed in this config file. It is a good
idea to load any logging plugins first in order to catch messages from plugins
during configuration. Also, the C<LoadPlugin> option B<must> occur B<before>
the appropriate C<E<lt>Plugin ...E<gt>> block.

=head1 GLOBAL OPTIONS

=over 4

=item B<BaseDir> I<Directory>

Sets the base directory. This is the directory beneath all RRD-files are
created. Possibly more subdirectories are created. This is also the working
directory for the daemon.

=item B<LoadPlugin> I<Plugin>

Loads the plugin I<Plugin>. This is required to load plugins, unless the
B<AutoLoadPlugin> option is enabled (see below). Without any loaded plugins,
I<collectd> will be mostly useless.

Only the first B<LoadPlugin> statement or block for a given plugin name has any
effect. This is useful when you want to split up the configuration into smaller
files and want each file to be "self contained", i.e. it contains a B<Plugin>
block I<and> then appropriate B<LoadPlugin> statement. The downside is that if
you have multiple conflicting B<LoadPlugin> blocks, e.g. when they specify
different intervals, only one of them (the first one encountered) will take
effect and all others will be silently ignored.

B<LoadPlugin> may either be a simple configuration I<statement> or a I<block>
with additional options, affecting the behavior of B<LoadPlugin>. A simple
statement looks like this:

 LoadPlugin "cpu"

Options inside a B<LoadPlugin> block can override default settings and
influence the way plugins are loaded, e.g.:

 <LoadPlugin perl>
   Globals true
   Interval 60
 </LoadPlugin>

The following options are valid inside B<LoadPlugin> blocks:

=over 4

=item B<Globals> B<true|false>

If enabled, collectd will export all global symbols of the plugin (and of all
libraries loaded as dependencies of the plugin) and, thus, makes those symbols
available for resolving unresolved symbols in subsequently loaded plugins if
that is supported by your system.

This is useful (or possibly even required), e.g., when loading a plugin that
embeds some scripting language into the daemon (e.g. the I<Perl> and
I<Python plugins>). Scripting languages usually provide means to load
extensions written in C. Those extensions require symbols provided by the
interpreter, which is loaded as a dependency of the respective collectd plugin.
See the documentation of those plugins (e.g., L<collectd-perl(5)> or
L<collectd-python(5)>) for details.

By default, this is disabled. As a special exception, if the plugin name is
either C<perl> or C<python>, the default is changed to enabled in order to keep
the average user from ever having to deal with this low level linking stuff.

=item B<Interval> I<Seconds>

Sets a plugin-specific interval for collecting metrics. This overrides the
global B<Interval> setting. If a plugin provides own support for specifying an
interval, that setting will take precedence.

=back

=item B<AutoLoadPlugin> B<false>|B<true>

When set to B<false> (the default), each plugin needs to be loaded explicitly,
using the B<LoadPlugin> statement documented above. If a
B<E<lt>PluginE<nbsp>...E<gt>> block is encountered and no configuration
handling callback for this plugin has been registered, a warning is logged and
the block is ignored.

When set to B<true>, explicit B<LoadPlugin> statements are not required. Each
B<E<lt>PluginE<nbsp>...E<gt>> block acts as if it was immediately preceded by a
B<LoadPlugin> statement. B<LoadPlugin> statements are still required for
plugins that don't provide any configuration, e.g. the I<Load plugin>.

=item B<Include> I<Path> [I<pattern>]

If I<Path> points to a file, includes that file. If I<Path> points to a
directory, recursively includes all files within that directory and its
subdirectories. If the C<wordexp> function is available on your system,
shell-like wildcards are expanded before files are included. This means you can
use statements like the following:

  Include "/etc/collectd.d/*.conf"

Starting with version 5.3, this may also be a block in which further options
affecting the behavior of B<Include> may be specified. The following option is
currently allowed:

  <Include "/etc/collectd.d">
    Filter "*.conf"
  </Include>

=over 4

=item B<Filter> I<pattern>

If the C<fnmatch> function is available on your system, a shell-like wildcard
I<pattern> may be specified to filter which files to include. This may be used
in combination with recursively including a directory to easily be able to
arbitrarily mix configuration files and other documents (e.g. README files).
The given example is similar to the first example above but includes all files
matching C<*.conf> in any subdirectory of C</etc/collectd.d>:

  Include "/etc/collectd.d" "*.conf"

=back

If more than one files are included by a single B<Include> option, the files
will be included in lexicographical order (as defined by the C<strcmp>
function). Thus, you can e.E<nbsp>g. use numbered prefixes to specify the
order in which the files are loaded.

To prevent loops and shooting yourself in the foot in interesting ways the
nesting is limited to a depth of 8E<nbsp>levels, which should be sufficient for
most uses. Since symlinks are followed it is still possible to crash the daemon
by looping symlinks. In our opinion significant stupidity should result in an
appropriate amount of pain.

It is no problem to have a block like C<E<lt>Plugin fooE<gt>> in more than one
file, but you cannot include files from within blocks.

=item B<PIDFile> I<File>

Sets where to write the PID file to. This file is overwritten when it exists
and deleted when the program is stopped. Some init-scripts might override this
setting using the B<-P> command-line option.

=item B<PluginDir> I<Directory>

Path to the plugins (shared objects) of collectd.

=item B<TypesDB> I<File> [I<File> ...]

Set one or more files that contain the data-set descriptions. See
L<types.db(5)> for a description of the format of this file.

=item B<Interval> I<Seconds>

Configures the interval in which to query the read plugins. Obviously smaller
values lead to a higher system load produced by collectd, while higher values
lead to more coarse statistics.

B<Warning:> You should set this once and then never touch it again. If you do,
I<you will have to delete all your RRD files> or know some serious RRDtool
magic! (Assuming you're using the I<RRDtool> or I<RRDCacheD> plugin.)

=item B<Timeout> I<Iterations>

Consider a value list "missing" when no update has been read or received for
I<Iterations> iterations. By default, I<collectd> considers a value list
missing when no update has been received for twice the update interval. Since
this setting uses iterations, the maximum allowed time without update depends
on the I<Interval> information contained in each value list. This is used in
the I<Threshold> configuration to dispatch notifications about missing values,
see L<collectd-threshold(5)> for details.

=item B<ReadThreads> I<Num>

Number of threads to start for reading plugins. The default value is B<5>, but
you may want to increase this if you have more than five plugins that take a
long time to read. Mostly those are plugins that do network-IO. Setting this to
a value higher than the number of registered read callbacks is not recommended.

=item B<WriteThreads> I<Num>

Number of threads to start for dispatching value lists to write plugins. The
default value is B<5>, but you may want to increase this if you have more than
five plugins that may take relatively long to write to.

=item B<WriteQueueLimitHigh> I<HighNum>

=item B<WriteQueueLimitLow> I<LowNum>

Metrics are read by the I<read threads> and then put into a queue to be handled
by the I<write threads>. If one of the I<write plugins> is slow (e.g. network
timeouts, I/O saturation of the disk) this queue will grow. In order to avoid
running into memory issues in such a case, you can limit the size of this
queue.

By default, there is no limit and memory may grow indefinitely. This is most
likely not an issue for clients, i.e. instances that only handle the local
metrics. For servers it is recommended to set this to a non-zero value, though.

You can set the limits using B<WriteQueueLimitHigh> and B<WriteQueueLimitLow>.
Each of them takes a numerical argument which is the number of metrics in the
queue. If there are I<HighNum> metrics in the queue, any new metrics I<will> be
dropped. If there are less than I<LowNum> metrics in the queue, all new metrics
I<will> be enqueued. If the number of metrics currently in the queue is between
I<LowNum> and I<HighNum>, the metric is dropped with a probability that is
proportional to the number of metrics in the queue (i.e. it increases linearly
until it reaches 100%.)

If B<WriteQueueLimitHigh> is set to non-zero and B<WriteQueueLimitLow> is
unset, the latter will default to half of B<WriteQueueLimitHigh>.

If you do not want to randomly drop values when the queue size is between
I<LowNum> and I<HighNum>, set If B<WriteQueueLimitHigh> and
B<WriteQueueLimitLow> to same value.

=item B<Hostname> I<Name>

Sets the hostname that identifies a host. If you omit this setting, the
hostname will be determined using the L<gethostname(2)> system call.

=item B<FQDNLookup> B<true|false>

If B<Hostname> is determined automatically this setting controls whether or not
the daemon should try to figure out the "fully qualified domain name", FQDN.
This is done using a lookup of the name returned by C<gethostname>. This option
is enabled by default.

=item B<PreCacheChain> I<ChainName>

=item B<PostCacheChain> I<ChainName>

Configure the name of the "pre-cache chain" and the "post-cache chain". Please
see L<FILTER CONFIGURATION> below on information on chains and how these
setting change the daemon's behavior.

=back

=head1 PLUGIN OPTIONS

Some plugins may register own options. These options must be enclosed in a
C<Plugin>-Section. Which options exist depends on the plugin used. Some plugins
require external configuration, too. The C<apache plugin>, for example,
required C<mod_status> to be configured in the webserver you're going to
collect data from. These plugins are listed below as well, even if they don't
require any configuration within collectd's configuration file.

A list of all plugins and a short summary for each plugin can be found in the
F<README> file shipped with the sourcecode and hopefully binary packets as
well.

=head2 Plugin C<aggregation>

The I<Aggregation plugin> makes it possible to aggregate several values into
one using aggregation functions such as I<sum>, I<average>, I<min> and I<max>.
This can be put to a wide variety of uses, e.g. average and total CPU
statistics for your entire fleet.

The grouping is powerful but, as with many powerful tools, may be a bit
difficult to wrap your head around. The grouping will therefore be
demonstrated using an example: The average and sum of the CPU usage across
all CPUs of each host is to be calculated.

To select all the affected values for our example, set C<Plugin cpu> and
C<Type cpu>. The other values are left unspecified, meaning "all values". The
I<Host>, I<Plugin>, I<PluginInstance>, I<Type> and I<TypeInstance> options
work as if they were specified in the C<WHERE> clause of an C<SELECT> SQL
statement.

  Plugin "cpu"
  Type "cpu"

Although the I<Host>, I<PluginInstance> (CPU number, i.e. 0, 1, 2, ...)  and
I<TypeInstance> (idle, user, system, ...) fields are left unspecified in the
example, the intention is to have a new value for each host / type instance
pair. This is achieved by "grouping" the values using the C<GroupBy> option.
It can be specified multiple times to group by more than one field.

  GroupBy "Host"
  GroupBy "TypeInstance"

We do neither specify nor group by I<plugin instance> (the CPU number), so all
metrics that differ in the CPU number only will be aggregated. Each
aggregation needs I<at least one> such field, otherwise no aggregation would
take place.

The full example configuration looks like this:

 <Plugin "aggregation">
   <Aggregation>
     Plugin "cpu"
     Type "cpu"
     
     GroupBy "Host"
     GroupBy "TypeInstance"
     
     CalculateSum true
     CalculateAverage true
   </Aggregation>
 </Plugin>

There are a couple of limitations you should be aware of:

=over 4

=item

The I<Type> cannot be left unspecified, because it is not reasonable to add
apples to oranges. Also, the internal lookup structure won't work if you try
to group by type.

=item

There must be at least one unspecified, ungrouped field. Otherwise nothing
will be aggregated.

=back

As you can see in the example above, each aggregation has its own
B<Aggregation> block. You can have multiple aggregation blocks and aggregation
blocks may match the same values, i.e. one value list can update multiple
aggregations. The following options are valid inside B<Aggregation> blocks:

=over 4

=item B<Host> I<Host>

=item B<Plugin> I<Plugin>

=item B<PluginInstance> I<PluginInstance>

=item B<Type> I<Type>

=item B<TypeInstance> I<TypeInstance>

Selects the value lists to be added to this aggregation. B<Type> must be a
valid data set name, see L<types.db(5)> for details.

If the string starts with and ends with a slash (C</>), the string is
interpreted as a I<regular expression>. The regex flavor used are POSIX
extended regular expressions as described in L<regex(7)>. Example usage:

 Host "/^db[0-9]\\.example\\.com$/"

=item B<GroupBy> B<Host>|B<Plugin>|B<PluginInstance>|B<TypeInstance>

Group valued by the specified field. The B<GroupBy> option may be repeated to
group by multiple fields.

=item B<SetHost> I<Host>

=item B<SetPlugin> I<Plugin>

=item B<SetPluginInstance> I<PluginInstance>

=item B<SetTypeInstance> I<TypeInstance>

Sets the appropriate part of the identifier to the provided string.

The I<PluginInstance> should include the placeholder C<%{aggregation}> which
will be replaced with the aggregation function, e.g. "average". Not including
the placeholder will result in duplication warnings and/or messed up values if
more than one aggregation function are enabled.

The following example calculates the average usage of all "even" CPUs:

 <Plugin "aggregation">
   <Aggregation>
     Plugin "cpu"
     PluginInstance "/[0,2,4,6,8]$/"
     Type "cpu"
     
     SetPlugin "cpu"
     SetPluginInstance "even-%{aggregation}"
     
     GroupBy "Host"
     GroupBy "TypeInstance"
     
     CalculateAverage true
   </Aggregation>
 </Plugin>

This will create the files:

=over 4

=item

foo.example.com/cpu-even-average/cpu-idle

=item

foo.example.com/cpu-even-average/cpu-system

=item

foo.example.com/cpu-even-average/cpu-user

=item

...

=back

=item B<CalculateNum> B<true>|B<false>

=item B<CalculateSum> B<true>|B<false>

=item B<CalculateAverage> B<true>|B<false>

=item B<CalculateMinimum> B<true>|B<false>

=item B<CalculateMaximum> B<true>|B<false>

=item B<CalculateStddev> B<true>|B<false>

Boolean options for enabling calculation of the number of value lists, their
sum, average, minimum, maximum andE<nbsp>/ or standard deviation. All options
are disabled by default.

=back

=head2 Plugin C<amqp>

The I<AMQMP plugin> can be used to communicate with other instances of
I<collectd> or third party applications using an AMQP message broker. Values
are sent to or received from the broker, which handles routing, queueing and
possibly filtering or messages.

 <Plugin "amqp">
   # Send values to an AMQP broker
   <Publish "some_name">
     Host "localhost"
     Port "5672"
     VHost "/"
     User "guest"
     Password "guest"
     Exchange "amq.fanout"
 #   ExchangeType "fanout"
 #   RoutingKey "collectd"
 #   Persistent false
 #   Format "command"
 #   StoreRates false
 #   GraphitePrefix "collectd."
 #   GraphiteEscapeChar "_"
   </Publish>
   
   # Receive values from an AMQP broker
   <Subscribe "some_name">
     Host "localhost"
     Port "5672"
     VHost "/"
     User "guest"
     Password "guest"
     Exchange "amq.fanout"
 #   ExchangeType "fanout"
 #   Queue "queue_name"
 #   RoutingKey "collectd.#"
   </Subscribe>
 </Plugin>

The plugin's configuration consists of a number of I<Publish> and I<Subscribe>
blocks, which configure sending and receiving of values respectively. The two
blocks are very similar, so unless otherwise noted, an option can be used in
either block. The name given in the blocks starting tag is only used for
reporting messages, but may be used to support I<flushing> of certain
I<Publish> blocks in the future.

=over 4

=item B<Host> I<Host>

Hostname or IP-address of the AMQP broker. Defaults to the default behavior of
the underlying communications library, I<rabbitmq-c>, which is "localhost".

=item B<Port> I<Port>

Service name or port number on which the AMQP broker accepts connections. This
argument must be a string, even if the numeric form is used. Defaults to
"5672".

=item B<VHost> I<VHost>

Name of the I<virtual host> on the AMQP broker to use. Defaults to "/".

=item B<User> I<User>

=item B<Password> I<Password>

Credentials used to authenticate to the AMQP broker. By default "guest"/"guest"
is used.

=item B<Exchange> I<Exchange>

In I<Publish> blocks, this option specifies the I<exchange> to send values to.
By default, "amq.fanout" will be used.

In I<Subscribe> blocks this option is optional. If given, a I<binding> between
the given exchange and the I<queue> is created, using the I<routing key> if
configured. See the B<Queue> and B<RoutingKey> options below.

=item B<ExchangeType> I<Type>

If given, the plugin will try to create the configured I<exchange> with this
I<type> after connecting. When in a I<Subscribe> block, the I<queue> will then
be bound to this exchange.

=item B<Queue> I<Queue> (Subscribe only)

Configures the I<queue> name to subscribe to. If no queue name was configures
explicitly, a unique queue name will be created by the broker.

=item B<RoutingKey> I<Key>

In I<Publish> blocks, this configures the routing key to set on all outgoing
messages. If not given, the routing key will be computed from the I<identifier>
of the value. The host, plugin, type and the two instances are concatenated
together using dots as the separator and all containing dots replaced with
slashes. For example "collectd.host/example/com.cpu.0.cpu.user". This makes it
possible to receive only specific values using a "topic" exchange.

In I<Subscribe> blocks, configures the I<routing key> used when creating a
I<binding> between an I<exchange> and the I<queue>. The usual wildcards can be
used to filter messages when using a "topic" exchange. If you're only
interested in CPU statistics, you could use the routing key "collectd.*.cpu.#"
for example.

=item B<Persistent> B<true>|B<false> (Publish only)

Selects the I<delivery method> to use. If set to B<true>, the I<persistent>
mode will be used, i.e. delivery is guaranteed. If set to B<false> (the
default), the I<transient> delivery mode will be used, i.e. messages may be
lost due to high load, overflowing queues or similar issues.

=item B<Format> B<Command>|B<JSON>|B<Graphite> (Publish only)

Selects the format in which messages are sent to the broker. If set to
B<Command> (the default), values are sent as C<PUTVAL> commands which are
identical to the syntax used by the I<Exec> and I<UnixSock plugins>. In this
case, the C<Content-Type> header field will be set to C<text/collectd>.

If set to B<JSON>, the values are encoded in the I<JavaScript Object Notation>,
an easy and straight forward exchange format. The C<Content-Type> header field
will be set to C<application/json>.

If set to B<Graphite>, values are encoded in the I<Graphite> format, which is
"<metric> <value> <timestamp>\n". The C<Content-Type> header field will be set to
C<text/graphite>.

A subscribing client I<should> use the C<Content-Type> header field to
determine how to decode the values. Currently, the I<AMQP plugin> itself can
only decode the B<Command> format.

=item B<StoreRates> B<true>|B<false> (Publish only)

Determines whether or not C<COUNTER>, C<DERIVE> and C<ABSOLUTE> data sources
are converted to a I<rate> (i.e. a C<GAUGE> value). If set to B<false> (the
default), no conversion is performed. Otherwise the conversion is performed
using the internal value cache.

Please note that currently this option is only used if the B<Format> option has
been set to B<JSON>.

=item B<GraphitePrefix> (Publish and B<Format>=I<Graphite> only)

A prefix can be added in the metric name when outputting in the I<Graphite> format.
It's added before the I<Host> name.
Metric name will be "<prefix><host><postfix><plugin><type><name>"

=item B<GraphitePostfix> (Publish and B<Format>=I<Graphite> only)

A postfix can be added in the metric name when outputting in the I<Graphite> format.
It's added after the I<Host> name.
Metric name will be "<prefix><host><postfix><plugin><type><name>"

=item B<GraphiteEscapeChar> (Publish and B<Format>=I<Graphite> only)

Specify a character to replace dots (.) in the host part of the metric name.
In I<Graphite> metric name, dots are used as separators between different
metric parts (host, plugin, type).
Default is "_" (I<Underscore>).

=back

=head2 Plugin C<apache>

To configure the C<apache>-plugin you first need to configure the Apache
webserver correctly. The Apache-plugin C<mod_status> needs to be loaded and
working and the C<ExtendedStatus> directive needs to be B<enabled>. You can use
the following snipped to base your Apache config upon:

  ExtendedStatus on
  <IfModule mod_status.c>
    <Location /mod_status>
      SetHandler server-status
    </Location>
  </IfModule>

Since its C<mod_status> module is very similar to Apache's, B<lighttpd> is
also supported. It introduces a new field, called C<BusyServers>, to count the
number of currently connected clients. This field is also supported.

The configuration of the I<Apache> plugin consists of one or more
C<E<lt>InstanceE<nbsp>/E<gt>> blocks. Each block requires one string argument
as the instance name. For example:

 <Plugin "apache">
   <Instance "www1">
     URL "http://www1.example.com/mod_status?auto"
   </Instance>
   <Instance "www2">
     URL "http://www2.example.com/mod_status?auto"
   </Instance>
 </Plugin>

The instance name will be used as the I<plugin instance>. To emulate the old
(versionE<nbsp>4) behavior, you can use an empty string (""). In order for the
plugin to work correctly, each instance name must be unique. This is not
enforced by the plugin and it is your responsibility to ensure it.

The following options are accepted within each I<Instance> block:

=over 4

=item B<URL> I<http://host/mod_status?auto>

Sets the URL of the C<mod_status> output. This needs to be the output generated
by C<ExtendedStatus on> and it needs to be the machine readable output
generated by appending the C<?auto> argument. This option is I<mandatory>.

=item B<User> I<Username>

Optional user name needed for authentication.

=item B<Password> I<Password>

Optional password needed for authentication.

=item B<VerifyPeer> B<true|false>

Enable or disable peer SSL certificate verification. See
L<http://curl.haxx.se/docs/sslcerts.html> for details. Enabled by default.

=item B<VerifyHost> B<true|false>

Enable or disable peer host name verification. If enabled, the plugin checks
if the C<Common Name> or a C<Subject Alternate Name> field of the SSL
certificate matches the host name provided by the B<URL> option. If this
identity check fails, the connection is aborted. Obviously, only works when
connecting to a SSL enabled server. Enabled by default.

=item B<CACert> I<File>

File that holds one or more SSL certificates. If you want to use HTTPS you will
possibly need this option. What CA certificates come bundled with C<libcurl>
and are checked by default depends on the distribution you use.

=back

=head2 Plugin C<apcups>

=over 4

=item B<Host> I<Hostname>

Hostname of the host running B<apcupsd>. Defaults to B<localhost>. Please note
that IPv6 support has been disabled unless someone can confirm or decline that
B<apcupsd> can handle it.

=item B<Port> I<Port>

TCP-Port to connect to. Defaults to B<3551>.

=item B<ReportSeconds> B<true|false>

If set to B<true>, the time reported in the C<timeleft> metric will be
converted to seconds. This is the recommended setting. If set to B<false>, the
default for backwards compatibility, the time will be reported in minutes.

=back

=head2 Plugin C<aquaero>

This plugin collects the value of the available sensors in an
I<AquaeroE<nbsp>5> board. AquaeroE<nbsp>5 is a water-cooling controller board,
manufactured by Aqua Computer GmbH L<http://www.aquacomputer.de/>, with a USB2
connection for monitoring and configuration. The board can handle multiple
temperature sensors, fans, water pumps and water level sensors and adjust the
output settings such as fan voltage or power used by the water pump based on
the available inputs using a configurable controller included in the board.
This plugin collects all the available inputs as well as some of the output
values chosen by this controller. The plugin is based on the I<libaquaero5>
library provided by I<aquatools-ng>.

=over 4

=item B<Device> I<DevicePath>

Device path of the AquaeroE<nbsp>5's USB HID (human interface device), usually
in the form C</dev/usb/hiddevX>. If this option is no set the plugin will try
to auto-detect the Aquaero 5 USB device based on vendor-ID and product-ID.

=back

=head2 Plugin C<ascent>

This plugin collects information about an Ascent server, a free server for the
"World of Warcraft" game. This plugin gathers the information by fetching the
XML status page using C<libcurl> and parses it using C<libxml2>.

The configuration options are the same as for the C<apache> plugin above:

=over 4

=item B<URL> I<http://localhost/ascent/status/>

Sets the URL of the XML status output.

=item B<User> I<Username>

Optional user name needed for authentication.

=item B<Password> I<Password>

Optional password needed for authentication.

=item B<VerifyPeer> B<true|false>

Enable or disable peer SSL certificate verification. See
L<http://curl.haxx.se/docs/sslcerts.html> for details. Enabled by default.

=item B<VerifyHost> B<true|false>

Enable or disable peer host name verification. If enabled, the plugin checks
if the C<Common Name> or a C<Subject Alternate Name> field of the SSL
certificate matches the host name provided by the B<URL> option. If this
identity check fails, the connection is aborted. Obviously, only works when
connecting to a SSL enabled server. Enabled by default.

=item B<CACert> I<File>

File that holds one or more SSL certificates. If you want to use HTTPS you will
possibly need this option. What CA certificates come bundled with C<libcurl>
and are checked by default depends on the distribution you use.

=back

=head2 Plugin C<bind>

Starting with BIND 9.5.0, the most widely used DNS server software provides
extensive statistics about queries, responses and lots of other information.
The bind plugin retrieves this information that's encoded in XML and provided
via HTTP and submits the values to collectd.

To use this plugin, you first need to tell BIND to make this information
available. This is done with the C<statistics-channels> configuration option:

 statistics-channels {
   inet localhost port 8053;
 };

The configuration follows the grouping that can be seen when looking at the
data with an XSLT compatible viewer, such as a modern web browser. It's
probably a good idea to make yourself familiar with the provided values, so you
can understand what the collected statistics actually mean.

Synopsis:

 <Plugin "bind">
   URL "http://localhost:8053/"
   ParseTime       false
   OpCodes         true
   QTypes          true
 
   ServerStats     true
   ZoneMaintStats  true
   ResolverStats   false
   MemoryStats     true
 
   <View "_default">
     QTypes        true
     ResolverStats true
     CacheRRSets   true
 
     Zone "127.in-addr.arpa/IN"
   </View>
 </Plugin>

The bind plugin accepts the following configuration options:

=over 4

=item B<URL> I<URL>

URL from which to retrieve the XML data. If not specified,
C<http://localhost:8053/> will be used.

=item B<ParseTime> B<true>|B<false>

When set to B<true>, the time provided by BIND will be parsed and used to
dispatch the values. When set to B<false>, the local time source is queried.

This setting is set to B<true> by default for backwards compatibility; setting
this to B<false> is I<recommended> to avoid problems with timezones and
localization.

=item B<OpCodes> B<true>|B<false>

When enabled, statistics about the I<"OpCodes">, for example the number of
C<QUERY> packets, are collected.

Default: Enabled.

=item B<QTypes> B<true>|B<false>

When enabled, the number of I<incoming> queries by query types (for example
C<A>, C<MX>, C<AAAA>) is collected.

Default: Enabled.

=item B<ServerStats> B<true>|B<false>

Collect global server statistics, such as requests received over IPv4 and IPv6,
successful queries, and failed updates.

Default: Enabled.

=item B<ZoneMaintStats> B<true>|B<false>

Collect zone maintenance statistics, mostly information about notifications
(zone updates) and zone transfers.

Default: Enabled.

=item B<ResolverStats> B<true>|B<false>

Collect resolver statistics, i.E<nbsp>e. statistics about outgoing requests
(e.E<nbsp>g. queries over IPv4, lame servers). Since the global resolver
counters apparently were removed in BIND 9.5.1 and 9.6.0, this is disabled by
default. Use the B<ResolverStats> option within a B<View "_default"> block
instead for the same functionality.

Default: Disabled.

=item B<MemoryStats>

Collect global memory statistics.

Default: Enabled.

=item B<View> I<Name>

Collect statistics about a specific I<"view">. BIND can behave different,
mostly depending on the source IP-address of the request. These different
configurations are called "views". If you don't use this feature, you most
likely are only interested in the C<_default> view.

Within a E<lt>B<View>E<nbsp>I<name>E<gt> block, you can specify which
information you want to collect about a view. If no B<View> block is
configured, no detailed view statistics will be collected.

=over 4

=item B<QTypes> B<true>|B<false>

If enabled, the number of I<outgoing> queries by query type (e.E<nbsp>g. C<A>,
C<MX>) is collected.

Default: Enabled.

=item B<ResolverStats> B<true>|B<false>

Collect resolver statistics, i.E<nbsp>e. statistics about outgoing requests
(e.E<nbsp>g. queries over IPv4, lame servers).

Default: Enabled.

=item B<CacheRRSets> B<true>|B<false>

If enabled, the number of entries (I<"RR sets">) in the view's cache by query
type is collected. Negative entries (queries which resulted in an error, for
example names that do not exist) are reported with a leading exclamation mark,
e.E<nbsp>g. "!A".

Default: Enabled.

=item B<Zone> I<Name>

When given, collect detailed information about the given zone in the view. The
information collected if very similar to the global B<ServerStats> information
(see above).

You can repeat this option to collect detailed information about multiple
zones.

By default no detailed zone information is collected.

=back

=back

=head2 Plugin C<cgroups>

This plugin collects the CPU user/system time for each I<cgroup> by reading the
F<cpuacct.stat> files in the first cpuacct-mountpoint (typically
F</sys/fs/cgroup/cpu.cpuacct> on machines using systemd).

=over 4

=item B<CGroup> I<Directory>

Select I<cgroup> based on the name. Whether only matching I<cgroups> are
collected or if they are ignored is controlled by the B<IgnoreSelected> option;
see below.

=item B<IgnoreSelected> B<true>|B<false>

Invert the selection: If set to true, all cgroups I<except> the ones that
match any one of the criteria are collected. By default only selected
cgroups are collected if a selection is made. If no selection is configured
at all, B<all> cgroups are selected.

=back

=head2 Plugin C<cpufreq>

This plugin doesn't have any options. It reads
F</sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq> (for the first CPU
installed) to get the current CPU frequency. If this file does not exist make
sure B<cpufreqd> (L<http://cpufreqd.sourceforge.net/>) or a similar tool is
installed and an "cpu governor" (that's a kernel module) is loaded.

=head2 Plugin C<csv>

=over 4

=item B<DataDir> I<Directory>

Set the directory to store CSV-files under. Per default CSV-files are generated
beneath the daemon's working directory, i.E<nbsp>e. the B<BaseDir>.
The special strings B<stdout> and B<stderr> can be used to write to the standard
output and standard error channels, respectively. This, of course, only makes
much sense when collectd is running in foreground- or non-daemon-mode.

=item B<StoreRates> B<true|false>

If set to B<true>, convert counter values to rates. If set to B<false> (the
default) counter values are stored as is, i.E<nbsp>e. as an increasing integer
number.

=back

=head2 Plugin C<curl>

The curl plugin uses the B<libcurl> (L<http://curl.haxx.se/>) to read web pages
and the match infrastructure (the same code used by the tail plugin) to use
regular expressions with the received data.

The following example will read the current value of AMD stock from Google's
finance page and dispatch the value to collectd.

  <Plugin curl>
    <Page "stock_quotes">
      URL "http://finance.google.com/finance?q=NYSE%3AAMD"
      User "foo"
      Password "bar"
      <Match>
        Regex "<span +class=\"pr\"[^>]*> *([0-9]*\\.[0-9]+) *</span>"
        DSType "GaugeAverage"
        # Note: `stock_value' is not a standard type.
        Type "stock_value"
        Instance "AMD"
      </Match>
    </Page>
  </Plugin>

In the B<Plugin> block, there may be one or more B<Page> blocks, each defining
a web page and one or more "matches" to be performed on the returned data. The
string argument to the B<Page> block is used as plugin instance.

The following options are valid within B<Page> blocks:

=over 4

=item B<URL> I<URL>

URL of the web site to retrieve. Since a regular expression will be used to
extract information from this data, non-binary data is a big plus here ;)

=item B<User> I<Name>

Username to use if authorization is required to read the page.

=item B<Password> I<Password>

Password to use if authorization is required to read the page.

=item B<VerifyPeer> B<true>|B<false>

Enable or disable peer SSL certificate verification. See
L<http://curl.haxx.se/docs/sslcerts.html> for details. Enabled by default.

=item B<VerifyHost> B<true>|B<false>

Enable or disable peer host name verification. If enabled, the plugin checks if
the C<Common Name> or a C<Subject Alternate Name> field of the SSL certificate
matches the host name provided by the B<URL> option. If this identity check
fails, the connection is aborted. Obviously, only works when connecting to a
SSL enabled server. Enabled by default.

=item B<CACert> I<file>

File that holds one or more SSL certificates. If you want to use HTTPS you will
possibly need this option. What CA certificates come bundled with C<libcurl>
and are checked by default depends on the distribution you use.

=item B<Header> I<Header>

A HTTP header to add to the request. Multiple headers are added if this option
is specified more than once.

=item B<Post> I<Body>

Specifies that the HTTP operation should be a POST instead of a GET. The
complete data to be posted is given as the argument.  This option will usually
need to be accompanied by a B<Header> option to set an appropriate
C<Content-Type> for the post body (e.g. to
C<application/x-www-form-urlencoded>).

=item B<MeasureResponseTime> B<true>|B<false>

Measure response time for the request. If this setting is enabled, B<Match>
blocks (see below) are optional. Disabled by default.

=item B<E<lt>MatchE<gt>>

One or more B<Match> blocks that define how to match information in the data
returned by C<libcurl>. The C<curl> plugin uses the same infrastructure that's
used by the C<tail> plugin, so please see the documentation of the C<tail>
plugin below on how matches are defined. If the B<MeasureResponseTime> option
is set to B<true>, B<Match> blocks are optional.

=back

=head2 Plugin C<curl_json>

The B<curl_json plugin> collects values from JSON data to be parsed by
B<libyajl> (L<http://www.lloydforge.org/projects/yajl/>) retrieved via
either B<libcurl> (L<http://curl.haxx.se/>) or read directly from a
unix socket. The former can be used, for example, to collect values
from CouchDB documents (which are stored JSON notation), and the
latter to collect values from a uWSGI stats socket.

The following example will collect several values from the built-in
C<_stats> runtime statistics module of I<CouchDB>
(L<http://wiki.apache.org/couchdb/Runtime_Statistics>).

  <Plugin curl_json>
    <URL "http://localhost:5984/_stats">
      Instance "httpd"
      <Key "httpd/requests/count">
        Type "http_requests"
      </Key>

      <Key "httpd_request_methods/*/count">
        Type "http_request_methods"
      </Key>

      <Key "httpd_status_codes/*/count">
        Type "http_response_codes"
      </Key>
    </URL>
  </Plugin>

This example will collect data directly from a I<uWSGI> "Stats Server" socket.

  <Plugin curl_json>
    <Sock "/var/run/uwsgi.stats.sock">
      Instance "uwsgi"
      <Key "workers/*/requests">
        Type "http_requests"
      </Key>

      <Key "workers/*/apps/*/requests">
        Type "http_requests"
      </Key>
    </Sock>
  </Plugin>

In the B<Plugin> block, there may be one or more B<URL> blocks, each
defining a URL to be fetched via HTTP (using libcurl) or B<Sock>
blocks defining a unix socket to read JSON from directly.  Each of
these blocks may have one or more B<Key> blocks.

The B<Key> string argument must be in a path format. Each component is
used to match the key from a JSON map or the index of an JSON
array. If a path component of a B<Key> is a I<*>E<nbsp>wildcard, the
values for all map keys or array indices will be collectd.

The following options are valid within B<URL> blocks:

=over 4

=item B<Instance> I<Instance>

Sets the plugin instance to I<Instance>.

=item B<User> I<Name>
=item B<Password> I<Password>
=item B<VerifyPeer> B<true>|B<false>
=item B<VerifyHost> B<true>|B<false>
=item B<CACert> I<file>
=item B<Header> I<Header>
=item B<Post> I<Body>

These options behave exactly equivalent to the appropriate options of the
I<cURL> plugin. Please see there for a detailed description.

=back

The following options are valid within B<Key> blocks:

=over 4

=item B<Type> I<Type>

Sets the type used to dispatch the values to the daemon. Detailed information
about types and their configuration can be found in L<types.db(5)>. This
option is mandatory.

=item B<Instance> I<Instance>

Type-instance to use. Defaults to the current map key or current string array element value.

=back

=head2 Plugin C<curl_xml>

The B<curl_xml plugin> uses B<libcurl> (L<http://curl.haxx.se/>) and B<libxml2>
(L<http://xmlsoft.org/>) to retrieve XML data via cURL.

 <Plugin "curl_xml">
   <URL "http://localhost/stats.xml">
     Host "my_host"
     Instance "some_instance"
     User "collectd"
     Password "thaiNg0I"
     VerifyPeer true
     VerifyHost true
     CACert "/path/to/ca.crt"

     <XPath "table[@id=\"magic_level\"]/tr">
       Type "magic_level"
       #InstancePrefix "prefix-"
       InstanceFrom "td[1]"
       ValuesFrom "td[2]/span[@class=\"level\"]"
     </XPath>
   </URL>
 </Plugin>

In the B<Plugin> block, there may be one or more B<URL> blocks, each defining a
URL to be fetched using libcurl. Within each B<URL> block there are
options which specify the connection parameters, for example authentication
information, and one or more B<XPath> blocks.

Each B<XPath> block specifies how to get one type of information. The
string argument must be a valid XPath expression which returns a list
of "base elements". One value is dispatched for each "base element". The
I<type instance> and values are looked up using further I<XPath> expressions
that should be relative to the base element.

Within the B<URL> block the following options are accepted:

=over 4

=item B<Host> I<Name>

Use I<Name> as the host name when submitting values. Defaults to the global
host name setting.

=item B<Instance> I<Instance>

Use I<Instance> as the plugin instance when submitting values. Defaults to an
empty string (no plugin instance).

=item B<Namespace> I<Prefix> I<URL>

If an XPath expression references namespaces, they must be specified
with this option. I<Prefix> is the "namespace prefix" used in the XML document.
I<URL> is the "namespace name", an URI reference uniquely identifying the
namespace. The option can be repeated to register multiple namespaces.

Examples:

  Namespace "s" "http://schemas.xmlsoap.org/soap/envelope/"
  Namespace "m" "http://www.w3.org/1998/Math/MathML"

=item B<User> I<User>

=item B<Password> I<Password>

=item B<VerifyPeer> B<true>|B<false>

=item B<VerifyHost> B<true>|B<false>

=item B<CACert> I<CA Cert File>

=item B<Header> I<Header>

=item B<Post> I<Body>

These options behave exactly equivalent to the appropriate options of the
I<cURL plugin>. Please see there for a detailed description.

=item E<lt>B<XPath> I<XPath-expression>E<gt>

Within each B<URL> block, there must be one or more B<XPath> blocks. Each
B<XPath> block specifies how to get one type of information. The string
argument must be a valid XPath expression which returns a list of "base
elements". One value is dispatched for each "base element".

Within the B<XPath> block the following options are accepted:

=over 4

=item B<Type> I<Type>

Specifies the I<Type> used for submitting patches. This determines the number
of values that are required / expected and whether the strings are parsed as
signed or unsigned integer or as double values. See L<types.db(5)> for details.
This option is required.

=item B<InstancePrefix> I<InstancePrefix>

Prefix the I<type instance> with I<InstancePrefix>. The values are simply
concatenated together without any separator.
This option is optional.

=item B<InstanceFrom> I<InstanceFrom>

Specifies a XPath expression to use for determining the I<type instance>. The
XPath expression must return exactly one element. The element's value is then
used as I<type instance>, possibly prefixed with I<InstancePrefix> (see above).

This value is required. As a special exception, if the "base XPath expression"
(the argument to the B<XPath> block) returns exactly one argument, then this
option may be omitted.

=item B<ValuesFrom> I<ValuesFrom> [I<ValuesFrom> ...]

Specifies one or more XPath expression to use for reading the values. The
number of XPath expressions must match the number of data sources in the
I<type> specified with B<Type> (see above). Each XPath expression must return
exactly one element. The element's value is then parsed as a number and used as
value for the appropriate value in the value list dispatched to the daemon.

=back

=back

=head2 Plugin C<dbi>

This plugin uses the B<dbi> library (L<http://libdbi.sourceforge.net/>) to
connect to various databases, execute I<SQL> statements and read back the
results. I<dbi> is an acronym for "database interface" in case you were
wondering about the name. You can configure how each column is to be
interpreted and the plugin will generate one or more data sets from each row
returned according to these rules.

Because the plugin is very generic, the configuration is a little more complex
than those of other plugins. It usually looks something like this:

  <Plugin dbi>
    <Query "out_of_stock">
      Statement "SELECT category, COUNT(*) AS value FROM products WHERE in_stock = 0 GROUP BY category"
      # Use with MySQL 5.0.0 or later
      MinVersion 50000
      <Result>
        Type "gauge"
        InstancePrefix "out_of_stock"
        InstancesFrom "category"
        ValuesFrom "value"
      </Result>
    </Query>
    <Database "product_information">
      Driver "mysql"
      DriverOption "host" "localhost"
      DriverOption "username" "collectd"
      DriverOption "password" "aZo6daiw"
      DriverOption "dbname" "prod_info"
      SelectDB "prod_info"
      Query "out_of_stock"
    </Database>
  </Plugin>

The configuration above defines one query with one result and one database. The
query is then linked to the database with the B<Query> option I<within> the
B<E<lt>DatabaseE<gt>> block. You can have any number of queries and databases
and you can also use the B<Include> statement to split up the configuration
file in multiple, smaller files. However, the B<E<lt>QueryE<gt>> block I<must>
precede the B<E<lt>DatabaseE<gt>> blocks, because the file is interpreted from
top to bottom!

The following is a complete list of options:

=head3 B<Query> blocks

Query blocks define I<SQL> statements and how the returned data should be
interpreted. They are identified by the name that is given in the opening line
of the block. Thus the name needs to be unique. Other than that, the name is
not used in collectd.

In each B<Query> block, there is one or more B<Result> blocks. B<Result> blocks
define which column holds which value or instance information. You can use
multiple B<Result> blocks to create multiple values from one returned row. This
is especially useful, when queries take a long time and sending almost the same
query again and again is not desirable.

Example:

  <Query "environment">
    Statement "select station, temperature, humidity from environment"
    <Result>
      Type "temperature"
      # InstancePrefix "foo"
      InstancesFrom "station"
      ValuesFrom "temperature"
    </Result>
    <Result>
      Type "humidity"
      InstancesFrom "station"
      ValuesFrom "humidity"
    </Result>
  </Query>

The following options are accepted:

=over 4

=item B<Statement> I<SQL>

Sets the statement that should be executed on the server. This is B<not>
interpreted by collectd, but simply passed to the database server. Therefore,
the SQL dialect that's used depends on the server collectd is connected to.

The query has to return at least two columns, one for the instance and one
value. You cannot omit the instance, even if the statement is guaranteed to
always return exactly one line. In that case, you can usually specify something
like this:

  Statement "SELECT \"instance\", COUNT(*) AS value FROM table"

(That works with MySQL but may not be valid SQL according to the spec. If you
use a more strict database server, you may have to select from a dummy table or
something.)

Please note that some databases, for example B<Oracle>, will fail if you
include a semicolon at the end of the statement.

=item B<MinVersion> I<Version>

=item B<MaxVersion> I<Value>

Only use this query for the specified database version. You can use these
options to provide multiple queries with the same name but with a slightly
different syntax. The plugin will use only those queries, where the specified
minimum and maximum versions fit the version of the database in use.

The database version is determined by C<dbi_conn_get_engine_version>, see the
L<libdbi documentation|http://libdbi.sourceforge.net/docs/programmers-guide/reference-conn.html#DBI-CONN-GET-ENGINE-VERSION>
for details. Basically, each part of the version is assumed to be in the range
from B<00> to B<99> and all dots are removed. So version "4.1.2" becomes
"40102", version "5.0.42" becomes "50042".

B<Warning:> The plugin will use B<all> matching queries, so if you specify
multiple queries with the same name and B<overlapping> ranges, weird stuff will
happen. Don't to it! A valid example would be something along these lines:

  MinVersion 40000
  MaxVersion 49999
  ...
  MinVersion 50000
  MaxVersion 50099
  ...
  MinVersion 50100
  # No maximum

In the above example, there are three ranges that don't overlap. The last one
goes from version "5.1.0" to infinity, meaning "all later versions". Versions
before "4.0.0" are not specified.

=item B<Type> I<Type>

The B<type> that's used for each line returned. See L<types.db(5)> for more
details on how types are defined. In short: A type is a predefined layout of
data and the number of values and type of values has to match the type
definition.

If you specify "temperature" here, you need exactly one gauge column. If you
specify "if_octets", you will need two counter columns. See the B<ValuesFrom>
setting below.

There must be exactly one B<Type> option inside each B<Result> block.

=item B<InstancePrefix> I<prefix>

Prepends I<prefix> to the type instance. If B<InstancesFrom> (see below) is not
given, the string is simply copied. If B<InstancesFrom> is given, I<prefix> and
all strings returned in the appropriate columns are concatenated together,
separated by dashes I<("-")>.

=item B<InstancesFrom> I<column0> [I<column1> ...]

Specifies the columns whose values will be used to create the "type-instance"
for each row. If you specify more than one column, the value of all columns
will be joined together with dashes I<("-")> as separation characters.

The plugin itself does not check whether or not all built instances are
different. It's your responsibility to assure that each is unique. This is
especially true, if you do not specify B<InstancesFrom>: B<You> have to make
sure that only one row is returned in this case.

If neither B<InstancePrefix> nor B<InstancesFrom> is given, the type-instance
will be empty.

=item B<ValuesFrom> I<column0> [I<column1> ...]

Names the columns whose content is used as the actual data for the data sets
that are dispatched to the daemon. How many such columns you need is determined
by the B<Type> setting above. If you specify too many or not enough columns,
the plugin will complain about that and no data will be submitted to the
daemon.

The actual data type in the columns is not that important. The plugin will
automatically cast the values to the right type if it know how to do that. So
it should be able to handle integer an floating point types, as well as strings
(if they include a number at the beginning).

There must be at least one B<ValuesFrom> option inside each B<Result> block.

=back

=head3 B<Database> blocks

Database blocks define a connection to a database and which queries should be
sent to that database. Since the used "dbi" library can handle a wide variety
of databases, the configuration is very generic. If in doubt, refer to libdbi's
documentationE<nbsp>- we stick as close to the terminology used there.

Each database needs a "name" as string argument in the starting tag of the
block. This name will be used as "PluginInstance" in the values submitted to
the daemon. Other than that, that name is not used.

=over 4

=item B<Driver> I<Driver>

Specifies the driver to use to connect to the database. In many cases those
drivers are named after the database they can connect to, but this is not a
technical necessity. These drivers are sometimes referred to as "DBD",
B<D>ataB<B>ase B<D>river, and some distributions ship them in separate
packages. Drivers for the "dbi" library are developed by the B<libdbi-drivers>
project at L<http://libdbi-drivers.sourceforge.net/>.

You need to give the driver name as expected by the "dbi" library here. You
should be able to find that in the documentation for each driver. If you
mistype the driver name, the plugin will dump a list of all known driver names
to the log.

=item B<DriverOption> I<Key> I<Value>

Sets driver-specific options. What option a driver supports can be found in the
documentation for each driver, somewhere at
L<http://libdbi-drivers.sourceforge.net/>. However, the options "host",
"username", "password", and "dbname" seem to be deE<nbsp>facto standards.

DBDs can register two types of options: String options and numeric options. The
plugin will use the C<dbi_conn_set_option> function when the configuration
provides a string and the C<dbi_conn_require_option_numeric> function when the
configuration provides a number. So these two lines will actually result in
different calls being used:

  DriverOption "Port" 1234      # numeric
  DriverOption "Port" "1234"    # string

Unfortunately, drivers are not too keen to report errors when an unknown option
is passed to them, so invalid settings here may go unnoticed. This is not the
plugin's fault, it will report errors if it gets them from the libraryE<nbsp>/
the driver. If a driver complains about an option, the plugin will dump a
complete list of all options understood by that driver to the log. There is no
way to programatically find out if an option expects a string or a numeric
argument, so you will have to refer to the appropriate DBD's documentation to
find this out. Sorry.

=item B<SelectDB> I<Database>

In some cases, the database name you connect with is not the database name you
want to use for querying data. If this option is set, the plugin will "select"
(switch to) that database after the connection is established.

=item B<Query> I<QueryName>

Associates the query named I<QueryName> with this database connection. The
query needs to be defined I<before> this statement, i.E<nbsp>e. all query
blocks you want to refer to must be placed above the database block you want to
refer to them from.

=item B<Host> I<Hostname>

Sets the B<host> field of I<value lists> to I<Hostname> when dispatching
values. Defaults to the global hostname setting.

=back

=head2 Plugin C<df>

=over 4

=item B<Device> I<Device>

Select partitions based on the devicename.

=item B<MountPoint> I<Directory>

Select partitions based on the mountpoint.

=item B<FSType> I<FSType>

Select partitions based on the filesystem type.

=item B<IgnoreSelected> B<true>|B<false>

Invert the selection: If set to true, all partitions B<except> the ones that
match any one of the criteria are collected. By default only selected
partitions are collected if a selection is made. If no selection is configured
at all, B<all> partitions are selected.

=item B<ReportByDevice> B<true>|B<false>

Report using the device name rather than the mountpoint. i.e. with this I<false>,
(the default), it will report a disk as "root", but with it I<true>, it will be
"sda1" (or whichever).

=item B<ReportInodes> B<true>|B<false>

Enables or disables reporting of free, reserved and used inodes. Defaults to
inode collection being disabled.

Enable this option if inodes are a scarce resource for you, usually because
many small files are stored on the disk. This is a usual scenario for mail
transfer agents and web caches.

=item B<ValuesAbsolute> B<true>|B<false>

Enables or disables reporting of free, used and used disk space in 1K-blocks.
Defaults to B<true>.

=item B<ValuesPercentage> B<false>|B<true>

Enables or disables reporting of free, used and used disk space in percentage.
Defaults to B<false>.

This is useful for deploying I<collectd> on the cloud, where machines with
different disk size may exist. Then it is more practical to configure
thresholds based on relative disk size.

=back

=head2 Plugin C<disk>

The C<disk> plugin collects information about the usage of physical disks and
logical disks (partitions). Values collected are the number of octets written
to and read from a disk or partition, the number of read/write operations
issued to the disk and a rather complex "time" it took for these commands to be
issued.

Using the following two options you can ignore some disks or configure the
collection only of specific disks.

=over 4

=item B<Disk> I<Name>

Select the disk I<Name>. Whether it is collected or ignored depends on the
B<IgnoreSelected> setting, see below. As with other plugins that use the
daemon's ignorelist functionality, a string that starts and ends with a slash
is interpreted as a regular expression. Examples:

  Disk "sdd"
  Disk "/hda[34]/"

=item B<IgnoreSelected> B<true>|B<false>

Sets whether selected disks, i.E<nbsp>e. the ones matches by any of the B<Disk>
statements, are ignored or if all other disks are ignored. The behavior
(hopefully) is intuitive: If no B<Disk> option is configured, all disks are
collected. If at least one B<Disk> option is given and no B<IgnoreSelected> or
set to B<false>, B<only> matching disks will be collected. If B<IgnoreSelected>
is set to B<true>, all disks are collected B<except> the ones matched.

=back

=head2 Plugin C<dns>

=over 4

=item B<Interface> I<Interface>

The dns plugin uses B<libpcap> to capture dns traffic and analyzes it. This
option sets the interface that should be used. If this option is not set, or
set to "any", the plugin will try to get packets from B<all> interfaces. This
may not work on certain platforms, such as MacE<nbsp>OSE<nbsp>X.

=item B<IgnoreSource> I<IP-address>

Ignore packets that originate from this address.

=item B<SelectNumericQueryTypes> B<true>|B<false>

Enabled by default, collects unknown (and thus presented as numeric only) query types.

=back

=head2 Plugin C<email>

=over 4

=item B<SocketFile> I<Path>

Sets the socket-file which is to be created.

=item B<SocketGroup> I<Group>

If running as root change the group of the UNIX-socket after it has been
created. Defaults to B<collectd>.

=item B<SocketPerms> I<Permissions>

Change the file permissions of the UNIX-socket after it has been created. The
permissions must be given as a numeric, octal value as you would pass to
L<chmod(1)>. Defaults to B<0770>.

=item B<MaxConns> I<Number>

Sets the maximum number of connections that can be handled in parallel. Since
this many threads will be started immediately setting this to a very high
value will waste valuable resources. Defaults to B<5> and will be forced to be
at most B<16384> to prevent typos and dumb mistakes.

=back

=head2 Plugin C<ethstat>

The I<ethstat plugin> collects information about network interface cards (NICs)
by talking directly with the underlying kernel driver using L<ioctl(2)>.

B<Synopsis:>

 <Plugin "ethstat">
   Interface "eth0"
   Map "rx_csum_offload_errors" "if_rx_errors" "checksum_offload"
   Map "multicast" "if_multicast"
 </Plugin>

B<Options:>

=over 4

=item B<Interface> I<Name>

Collect statistical information about interface I<Name>.

=item B<Map> I<Name> I<Type> [I<TypeInstance>]

By default, the plugin will submit values as type C<derive> and I<type
instance> set to I<Name>, the name of the metric as reported by the driver. If
an appropriate B<Map> option exists, the given I<Type> and, optionally,
I<TypeInstance> will be used.

=item B<MappedOnly> B<true>|B<false>

When set to B<true>, only metrics that can be mapped to to a I<type> will be
collected, all other metrics will be ignored. Defaults to B<false>.

=back

=head2 Plugin C<exec>

Please make sure to read L<collectd-exec(5)> before using this plugin. It
contains valuable information on when the executable is executed and the
output that is expected from it.

=over 4

=item B<Exec> I<User>[:[I<Group>]] I<Executable> [I<E<lt>argE<gt>> [I<E<lt>argE<gt>> ...]]

=item B<NotificationExec> I<User>[:[I<Group>]] I<Executable> [I<E<lt>argE<gt>> [I<E<lt>argE<gt>> ...]]

Execute the executable I<Executable> as user I<User>. If the user name is
followed by a colon and a group name, the effective group is set to that group.
The real group and saved-set group will be set to the default group of that
user. If no group is given the effective group ID will be the same as the real
group ID.

Please note that in order to change the user and/or group the daemon needs
superuser privileges. If the daemon is run as an unprivileged user you must
specify the same user/group here. If the daemon is run with superuser
privileges, you must supply a non-root user here.

The executable may be followed by optional arguments that are passed to the
program. Please note that due to the configuration parsing numbers and boolean
values may be changed. If you want to be absolutely sure that something is
passed as-is please enclose it in quotes.

The B<Exec> and B<NotificationExec> statements change the semantics of the
programs executed, i.E<nbsp>e. the data passed to them and the response
expected from them. This is documented in great detail in L<collectd-exec(5)>.

=back

=head2 Plugin C<filecount>

The C<filecount> plugin counts the number of files in a certain directory (and
its subdirectories) and their combined size. The configuration is very straight
forward:

  <Plugin "filecount">
    <Directory "/var/qmail/queue/mess">
      Instance "qmail-message"
    </Directory>
    <Directory "/var/qmail/queue/todo">
      Instance "qmail-todo"
    </Directory>
    <Directory "/var/lib/php5">
      Instance "php5-sessions"
      Name "sess_*"
    </Directory>
  </Plugin>

The example above counts the number of files in QMail's queue directories and
the number of PHP5 sessions. Jfiy: The "todo" queue holds the messages that
QMail has not yet looked at, the "message" queue holds the messages that were
classified into "local" and "remote".

As you can see, the configuration consists of one or more C<Directory> blocks,
each of which specifies a directory in which to count the files. Within those
blocks, the following options are recognized:

=over 4

=item B<Instance> I<Instance>

Sets the plugin instance to I<Instance>. That instance name must be unique, but
it's your responsibility, the plugin doesn't check for that. If not given, the
instance is set to the directory name with all slashes replaced by underscores
and all leading underscores removed.

=item B<Name> I<Pattern>

Only count files that match I<Pattern>, where I<Pattern> is a shell-like
wildcard as understood by L<fnmatch(3)>. Only the B<filename> is checked
against the pattern, not the entire path. In case this makes it easier for you:
This option has been named after the B<-name> parameter to L<find(1)>.

=item B<MTime> I<Age>

Count only files of a specific age: If I<Age> is greater than zero, only files
that haven't been touched in the last I<Age> seconds are counted. If I<Age> is
a negative number, this is inversed. For example, if B<-60> is specified, only
files that have been modified in the last minute will be counted.

The number can also be followed by a "multiplier" to easily specify a larger
timespan. When given in this notation, the argument must in quoted, i.E<nbsp>e.
must be passed as string. So the B<-60> could also be written as B<"-1m"> (one
minute). Valid multipliers are C<s> (second), C<m> (minute), C<h> (hour), C<d>
(day), C<w> (week), and C<y> (year). There is no "month" multiplier. You can
also specify fractional numbers, e.E<nbsp>g. B<"0.5d"> is identical to
B<"12h">.

=item B<Size> I<Size>

Count only files of a specific size. When I<Size> is a positive number, only
files that are at least this big are counted. If I<Size> is a negative number,
this is inversed, i.E<nbsp>e. only files smaller than the absolute value of
I<Size> are counted.

As with the B<MTime> option, a "multiplier" may be added. For a detailed
description see above. Valid multipliers here are C<b> (byte), C<k> (kilobyte),
C<m> (megabyte), C<g> (gigabyte), C<t> (terabyte), and C<p> (petabyte). Please
note that there are 1000 bytes in a kilobyte, not 1024.

=item B<Recursive> I<true>|I<false>

Controls whether or not to recurse into subdirectories. Enabled by default.

=item B<IncludeHidden> I<true>|I<false>

Controls whether or not to include "hidden" files and directories in the count.
"Hidden" files and directories are those, whose name begins with a dot.
Defaults to I<false>, i.e. by default hidden files and directories are ignored.

=back

=head2 Plugin C<GenericJMX>

The I<GenericJMX plugin> is written in I<Java> and therefore documented in
L<collectd-java(5)>.

=head2 Plugin C<gmond>

The I<gmond> plugin received the multicast traffic sent by B<gmond>, the
statistics collection daemon of Ganglia. Mappings for the standard "metrics"
are built-in, custom mappings may be added via B<Metric> blocks, see below.

Synopsis:

 <Plugin "gmond">
   MCReceiveFrom "239.2.11.71" "8649"
   <Metric "swap_total">
     Type "swap"
     TypeInstance "total"
     DataSource "value"
   </Metric>
   <Metric "swap_free">
     Type "swap"
     TypeInstance "free"
     DataSource "value"
   </Metric>
 </Plugin>

The following metrics are built-in:

=over 4

=item *

load_one, load_five, load_fifteen

=item *

cpu_user, cpu_system, cpu_idle, cpu_nice, cpu_wio

=item *

mem_free, mem_shared, mem_buffers, mem_cached, mem_total

=item *

bytes_in, bytes_out

=item *

pkts_in, pkts_out

=back

Available configuration options:

=over 4

=item B<MCReceiveFrom> I<MCGroup> [I<Port>]

Sets sets the multicast group and UDP port to which to subscribe.

Default: B<239.2.11.71>E<nbsp>/E<nbsp>B<8649>

=item E<lt>B<Metric> I<Name>E<gt>

These blocks add a new metric conversion to the internal table. I<Name>, the
string argument to the B<Metric> block, is the metric name as used by Ganglia.

=over 4

=item B<Type> I<Type>

Type to map this metric to. Required.

=item B<TypeInstance> I<Instance>

Type-instance to use. Optional.

=item B<DataSource> I<Name>

Data source to map this metric to. If the configured type has exactly one data
source, this is optional. Otherwise the option is required.

=back

=back

=head2 Plugin C<hddtemp>

To get values from B<hddtemp> collectd connects to B<localhost> (127.0.0.1),
port B<7634/tcp>. The B<Host> and B<Port> options can be used to change these
default values, see below. C<hddtemp> has to be running to work correctly. If
C<hddtemp> is not running timeouts may appear which may interfere with other
statistics..

The B<hddtemp> homepage can be found at
L<http://www.guzu.net/linux/hddtemp.php>.

=over 4

=item B<Host> I<Hostname>

Hostname to connect to. Defaults to B<127.0.0.1>.

=item B<Port> I<Port>

TCP-Port to connect to. Defaults to B<7634>.

=back

=head2 Plugin C<interface>

=over 4

=item B<Interface> I<Interface>

Select this interface. By default these interfaces will then be collected. For
a more detailed description see B<IgnoreSelected> below.

=item B<IgnoreSelected> I<true>|I<false>

If no configuration if given, the B<traffic>-plugin will collect data from
all interfaces. This may not be practical, especially for loopback- and
similar interfaces. Thus, you can use the B<Interface>-option to pick the
interfaces you're interested in. Sometimes, however, it's easier/preferred
to collect all interfaces I<except> a few ones. This option enables you to
do that: By setting B<IgnoreSelected> to I<true> the effect of
B<Interface> is inverted: All selected interfaces are ignored and all
other interfaces are collected.

=back

=head2 Plugin C<ipmi>

=over 4

=item B<Sensor> I<Sensor>

Selects sensors to collect or to ignore, depending on B<IgnoreSelected>.

=item B<IgnoreSelected> I<true>|I<false>

If no configuration if given, the B<ipmi> plugin will collect data from all
sensors found of type "temperature", "voltage", "current" and "fanspeed".
This option enables you to do that: By setting B<IgnoreSelected> to I<true>
the effect of B<Sensor> is inverted: All selected sensors are ignored and
all other sensors are collected.

=item B<NotifySensorAdd> I<true>|I<false>

If a sensor appears after initialization time of a minute a notification
is sent.

=item B<NotifySensorRemove> I<true>|I<false>

If a sensor disappears a notification is sent.

=item B<NotifySensorNotPresent> I<true>|I<false>

If you have for example dual power supply and one of them is (un)plugged then
a notification is sent.

=back

=head2 Plugin C<iptables>

=over 4

=item B<Chain> I<Table> I<Chain> [I<Comment|Number> [I<Name>]]

Select the rules to count. If only I<Table> and I<Chain> are given, this plugin
will collect the counters of all rules which have a comment-match. The comment
is then used as type-instance.

If I<Comment> or I<Number> is given, only the rule with the matching comment or
the I<n>th rule will be collected. Again, the comment (or the number) will be
used as the type-instance.

If I<Name> is supplied, it will be used as the type-instance instead of the
comment or the number.

=back

=head2 Plugin C<irq>

=over 4

=item B<Irq> I<Irq>

Select this irq. By default these irqs will then be collected. For a more
detailed description see B<IgnoreSelected> below.

=item B<IgnoreSelected> I<true>|I<false>

If no configuration if given, the B<irq>-plugin will collect data from all
irqs. This may not be practical, especially if no interrupts happen. Thus, you
can use the B<Irq>-option to pick the interrupt you're interested in.
Sometimes, however, it's easier/preferred to collect all interrupts I<except> a
few ones. This option enables you to do that: By setting B<IgnoreSelected> to
I<true> the effect of B<Irq> is inverted: All selected interrupts are ignored
and all other interrupts are collected.

=back

=head2 Plugin C<java>

The I<Java> plugin makes it possible to write extensions for collectd in Java.
This section only discusses the syntax and semantic of the configuration
options. For more in-depth information on the I<Java> plugin, please read
L<collectd-java(5)>.

Synopsis:

 <Plugin "java">
   JVMArg "-verbose:jni"
   JVMArg "-Djava.class.path=/opt/collectd/lib/collectd/bindings/java"
   LoadPlugin "org.collectd.java.Foobar"
   <Plugin "org.collectd.java.Foobar">
     # To be parsed by the plugin
   </Plugin>
 </Plugin>

Available configuration options:

=over 4

=item B<JVMArg> I<Argument>

Argument that is to be passed to the I<Java Virtual Machine> (JVM). This works
exactly the way the arguments to the I<java> binary on the command line work.
Execute C<javaE<nbsp>--help> for details.

Please note that B<all> these options must appear B<before> (i.E<nbsp>e. above)
any other options! When another option is found, the JVM will be started and
later options will have to be ignored!

=item B<LoadPlugin> I<JavaClass>

Instantiates a new I<JavaClass> object. The constructor of this object very
likely then registers one or more callback methods with the server.

See L<collectd-java(5)> for details.

When the first such option is found, the virtual machine (JVM) is created. This
means that all B<JVMArg> options must appear before (i.E<nbsp>e. above) all
B<LoadPlugin> options!

=item B<Plugin> I<Name>

The entire block is passed to the Java plugin as an
I<org.collectd.api.OConfigItem> object.

For this to work, the plugin has to register a configuration callback first,
see L<collectd-java(5)/"config callback">. This means, that the B<Plugin> block
must appear after the appropriate B<LoadPlugin> block. Also note, that I<Name>
depends on the (Java) plugin registering the callback and is completely
independent from the I<JavaClass> argument passed to B<LoadPlugin>.

=back

=head2 Plugin C<libvirt>

This plugin allows CPU, disk and network load to be collected for virtualized
guests on the machine. This means that these characteristics can be collected
for guest systems without installing any software on them - collectd only runs
on the hosting system. The statistics are collected through libvirt
(L<http://libvirt.org/>).

Only I<Connection> is required.

=over 4

=item B<Connection> I<uri>

Connect to the hypervisor given by I<uri>. For example if using Xen use:

 Connection "xen:///"

Details which URIs allowed are given at L<http://libvirt.org/uri.html>.

=item B<RefreshInterval> I<seconds>

Refresh the list of domains and devices every I<seconds>. The default is 60
seconds. Setting this to be the same or smaller than the I<Interval> will cause
the list of domains and devices to be refreshed on every iteration.

Refreshing the devices in particular is quite a costly operation, so if your
virtualization setup is static you might consider increasing this. If this
option is set to 0, refreshing is disabled completely.

=item B<Domain> I<name>

=item B<BlockDevice> I<name:dev>

=item B<InterfaceDevice> I<name:dev>

=item B<IgnoreSelected> I<true>|I<false>

Select which domains and devices are collected.

If I<IgnoreSelected> is not given or I<false> then only the listed domains and
disk/network devices are collected.

If I<IgnoreSelected> is I<true> then the test is reversed and the listed
domains and disk/network devices are ignored, while the rest are collected.

The domain name and device names may use a regular expression, if the name is
surrounded by I</.../> and collectd was compiled with support for regexps.

The default is to collect statistics for all domains and all their devices.

Example:

 BlockDevice "/:hdb/"
 IgnoreSelected "true"

Ignore all I<hdb> devices on any domain, but other block devices (eg. I<hda>)
will be collected.

=item B<HostnameFormat> B<name|uuid|hostname|...>

When the libvirt plugin logs data, it sets the hostname of the collected data
according to this setting. The default is to use the guest name as provided by
the hypervisor, which is equal to setting B<name>.

B<uuid> means use the guest's UUID. This is useful if you want to track the
same guest across migrations.

B<hostname> means to use the global B<Hostname> setting, which is probably not
useful on its own because all guests will appear to have the same name.

You can also specify combinations of these fields. For example B<name uuid>
means to concatenate the guest name and UUID (with a literal colon character
between, thus I<"foo:1234-1234-1234-1234">).

=item B<InterfaceFormat> B<name>|B<address>

When the libvirt plugin logs interface data, it sets the name of the collected
data according to this setting. The default is to use the path as provided by
the hypervisor (the "dev" property of the target node), which is equal to
setting B<name>.

B<address> means use the interface's mac address. This is useful since the
interface path might change between reboots of a guest or across migrations.

=back

+=head2 Plugin C<load>

The I<Load plugin> collects the system load. These numbers give a rough overview
over the utilization of a machine. The system load is defined as the number of
runnable tasks in the run-queue and is provided by many operating systems as a
one, five or fifteen minute average.

The following configuration options are available:

=over 4

=item B<ReportRelative> B<false>|B<true>

When enabled, system load divided by number of available CPU cores is reported
for intervals 1 min, 5 min and 15 min. Defaults to false.

=back


=head2 Plugin C<logfile>

=over 4

=item B<LogLevel> B<debug|info|notice|warning|err>

Sets the log-level. If, for example, set to B<notice>, then all events with
severity B<notice>, B<warning>, or B<err> will be written to the logfile.

Please note that B<debug> is only available if collectd has been compiled with
debugging support.

=item B<File> I<File>

Sets the file to write log messages to. The special strings B<stdout> and
B<stderr> can be used to write to the standard output and standard error
channels, respectively. This, of course, only makes much sense when I<collectd>
is running in foreground- or non-daemon-mode.

=item B<Timestamp> B<true>|B<false>

Prefix all lines printed by the current time. Defaults to B<true>.

=item B<PrintSeverity> B<true>|B<false>

When enabled, all lines are prefixed by the severity of the log message, for
example "warning". Defaults to B<false>.

=back

B<Note>: There is no need to notify the daemon after moving or removing the
log file (e.E<nbsp>g. when rotating the logs). The plugin reopens the file
for each line it writes.

=head2 Plugin C<lpar>

The I<LPAR plugin> reads CPU statistics of I<Logical Partitions>, a
virtualization technique for IBM POWER processors. It takes into account CPU
time stolen from or donated to a partition, in addition to the usual user,
system, I/O statistics.

The following configuration options are available:

=over 4

=item B<CpuPoolStats> B<false>|B<true>

When enabled, statistics about the processor pool are read, too. The partition
needs to have pool authority in order to be able to acquire this information.
Defaults to false.

=item B<ReportBySerial> B<false>|B<true>

If enabled, the serial of the physical machine the partition is currently
running on is reported as I<hostname> and the logical hostname of the machine
is reported in the I<plugin instance>. Otherwise, the logical hostname will be
used (just like other plugins) and the I<plugin instance> will be empty.
Defaults to false.

=back

=head2 Plugin C<mbmon>

The C<mbmon plugin> uses mbmon to retrieve temperature, voltage, etc.

Be default collectd connects to B<localhost> (127.0.0.1), port B<411/tcp>. The
B<Host> and B<Port> options can be used to change these values, see below.
C<mbmon> has to be running to work correctly. If C<mbmon> is not running
timeouts may appear which may interfere with other statistics..

C<mbmon> must be run with the -r option ("print TAG and Value format");
Debian's F</etc/init.d/mbmon> script already does this, other people
will need to ensure that this is the case.

=over 4

=item B<Host> I<Hostname>

Hostname to connect to. Defaults to B<127.0.0.1>.

=item B<Port> I<Port>

TCP-Port to connect to. Defaults to B<411>.

=back

=head2 Plugin C<md>

The C<md plugin> collects information from Linux Software-RAID devices (md).

All reported values are of the type C<md_disks>. Reported type instances are
I<active>, I<failed> (present but not operational), I<spare> (hot stand-by) and
I<missing> (physically absent) disks.

=over 4

=item B<Device> I<Device>

Select md devices based on device name. The I<device name> is the basename of
the device, i.e. the name of the block device without the leading C</dev/>.
See B<IgnoreSelected> for more details.

=item B<IgnoreSelected> B<true>|B<false>

Invert device selection: If set to B<true>, all md devices B<except> those
listed using B<Device> are collected. If B<false> (the default), only those
listed are collected. If no configuration is given, the B<md> plugin will
collect data from all md devices.

=back

=head2 Plugin C<memcachec>

The C<memcachec plugin> connects to a memcached server, queries one or more
given I<pages> and parses the returned data according to user specification.
The I<matches> used are the same as the matches used in the C<curl> and C<tail>
plugins.

In order to talk to the memcached server, this plugin uses the I<libmemcached>
library. Please note that there is another library with a very similar name,
libmemcache (notice the missing `d'), which is not applicable.

Synopsis of the configuration:

 <Plugin "memcachec">
   <Page "plugin_instance">
     Server "localhost"
     Key "page_key"
     <Match>
       Regex "(\\d+) bytes sent"
       DSType CounterAdd
       Type "ipt_octets"
       Instance "type_instance"
     </Match>
   </Page>
 </Plugin>

The configuration options are:

=over 4

=item E<lt>B<Page> I<Name>E<gt>

Each B<Page> block defines one I<page> to be queried from the memcached server.
The block requires one string argument which is used as I<plugin instance>.

=item B<Server> I<Address>

Sets the server address to connect to when querying the page. Must be inside a
B<Page> block.

=item B<Key> I<Key>

When connected to the memcached server, asks for the page I<Key>.

=item E<lt>B<Match>E<gt>

Match blocks define which strings to look for and how matches substrings are
interpreted. For a description of match blocks, please see L<"Plugin tail">.

=back

=head2 Plugin C<memcached>

The B<memcached plugin> connects to a memcached server and queries statistics
about cache utilization, memory and bandwidth used.
L<http://www.danga.com/memcached/>

 <Plugin "memcached">
   <Instance "name">
     Host "memcache.example.com"
     Port 11211
   </Instance>
 </Plugin>

The plugin configuration consists of one or more B<Instance> blocks which
specify one I<memcached> connection each. Within the B<Instance> blocks, the
following options are allowed:

=over 4

=item B<Host> I<Hostname>

Hostname to connect to. Defaults to B<127.0.0.1>.

=item B<Port> I<Port>

TCP-Port to connect to. Defaults to B<11211>.

=item B<Socket> I<Path>

Connect to I<memcached> using the UNIX domain socket at I<Path>. If this
setting is given, the B<Host> and B<Port> settings are ignored.

=back

=head2 Plugin C<mic>

The B<mic plugin> gathers CPU statistics, memory usage and temperatures from
Intel's Many Integrated Core (MIC) systems.

B<Synopsis:>

 <Plugin mic>
   ShowCPU true
   ShowCPUCores true
   ShowMemory true
   
   ShowTemperatures true
   Temperature vddg
   Temperature vddq
   IgnoreSelectedTemperature true
   
   ShowPower true
   Power total0
   Power total1
   IgnoreSelectedPower true
 </Plugin>

The following options are valid inside the B<PluginE<nbsp>mic> block:

=over 4

=item B<ShowCPU> B<true>|B<false>

If enabled (the default) a sum of the CPU usage accross all cores is reported.

=item B<ShowCPUCores> B<true>|B<false>

If enabled (the default) per-core CPU usage is reported.

=item B<ShowMemory> B<true>|B<false>

If enabled (the default) the physical memory usage of the MIC system is
reported.

=item B<ShowTemperatures> B<true>|B<false>

If enabled (the default) various temperatures of the MIC system are reported.

=item B<Temperature> I<Name>

This option controls which temperatures are being reported. Whether matching
temperatures are being ignored or I<only> matching temperatures are reported
depends on the B<IgnoreSelectedTemperature> setting below. By default I<all>
temperatures are reported.

=item B<IgnoreSelectedTemperature> B<false>|B<true>

Controls the behavior of the B<Temperature> setting above. If set to B<false>
(the default) only temperatures matching a B<Temperature> option are reported
or, if no B<Temperature> option is specified, all temperatures are reported. If
set to B<true>, matching temperatures are I<ignored> and all other temperatures
are reported.

Known temperature names are:

=over 4

=item die

Die of the CPU

=item devmem

Device Memory

=item fin

Fan In

=item fout

Fan Out

=item vccp

Voltage ccp

=item vddg

Voltage ddg

=item vddq

Voltage ddq

=back

=item B<ShowPower> B<true>|B<false>

If enabled (the default) various temperatures of the MIC system are reported.

=item B<Power> I<Name>

This option controls which power readings are being reported. Whether matching
power readings are being ignored or I<only> matching power readings are reported
depends on the B<IgnoreSelectedPower> setting below. By default I<all>
power readings are reported.

=item B<IgnoreSelectedPower> B<false>|B<true>

Controls the behavior of the B<Power> setting above. If set to B<false>
(the default) only power readings matching a B<Power> option are reported
or, if no B<Power> option is specified, all power readings are reported. If
set to B<true>, matching power readings are I<ignored> and all other power readings
are reported.

Known power names are:

=over 4

=item total0

Total power utilization averaged over Time Window 0 (uWatts).

=item total1

Total power utilization averaged over Time Window 0 (uWatts).

=item inst

Instantaneous power (uWatts).

=item imax

Max instantaneous power (uWatts).

=item pcie

PCI-E connector power (uWatts).

=item c2x3

2x3 connector power (uWatts).

=item c2x4

2x4 connector power (uWatts).

=item vccp

Core rail (uVolts).

=item vddg

Uncore rail (uVolts).

=item vddq

Memory subsystem rail (uVolts).

=back

=back

=head2 Plugin C<modbus>

The B<modbus plugin> connects to a Modbus "slave" via Modbus/TCP and reads
register values. It supports reading single registers (unsigned 16E<nbsp>bit
values), large integer values (unsigned 32E<nbsp>bit values) and floating point
values (two registers interpreted as IEEE floats in big endian notation).

B<Synopsis:>

 <Data "voltage-input-1">
   RegisterBase 0
   RegisterType float
   Type voltage
   Instance "input-1"
 </Data>
 
 <Data "voltage-input-2">
   RegisterBase 2
   RegisterType float
   Type voltage
   Instance "input-2"
 </Data>
 
 <Host "modbus.example.com">
   Address "192.168.0.42"
   Port    "502"
   Interval 60
   
   <Slave 1>
     Instance "power-supply"
     Collect  "voltage-input-1"
     Collect  "voltage-input-2"
   </Slave>
 </Host>

=over 4

=item E<lt>B<Data> I<Name>E<gt> blocks

Data blocks define a mapping between register numbers and the "types" used by
I<collectd>.

Within E<lt>DataE<nbsp>/E<gt> blocks, the following options are allowed:

=over 4

=item B<RegisterBase> I<Number>

Configures the base register to read from the device. If the option
B<RegisterType> has been set to B<Uint32> or B<Float>, this and the next
register will be read (the register number is increased by one).

=item B<RegisterType> B<Int16>|B<Int32>|B<Uint16>|B<Uint32>|B<Float>

Specifies what kind of data is returned by the device. If the type is B<Int32>,
B<Uint32> or B<Float>, two 16E<nbsp>bit registers will be read and the data is
combined into one value. Defaults to B<Uint16>.

=item B<Type> I<Type>

Specifies the "type" (data set) to use when dispatching the value to
I<collectd>. Currently, only data sets with exactly one data source are
supported.

=item B<Instance> I<Instance>

Sets the type instance to use when dispatching the value to I<collectd>. If
unset, an empty string (no type instance) is used.

=back

=item E<lt>B<Host> I<Name>E<gt> blocks

Host blocks are used to specify to which hosts to connect and what data to read
from their "slaves". The string argument I<Name> is used as hostname when
dispatching the values to I<collectd>.

Within E<lt>HostE<nbsp>/E<gt> blocks, the following options are allowed:

=over 4

=item B<Address> I<Hostname>

Specifies the node name (the actual network address) used to connect to the
host. This may be an IP address or a hostname. Please note that the used
I<libmodbus> library only supports IPv4 at the moment.

=item B<Port> I<Service>

Specifies the port used to connect to the host. The port can either be given as
a number or as a service name. Please note that the I<Service> argument must be
a string, even if ports are given in their numerical form. Defaults to "502".

=item B<Interval> I<Interval>

Sets the interval (in seconds) in which the values will be collected from this
host. By default the global B<Interval> setting will be used.

=item E<lt>B<Slave> I<ID>E<gt>

Over each TCP connection, multiple Modbus devices may be reached. The slave ID
is used to specify which device should be addressed. For each device you want
to query, one B<Slave> block must be given.

Within E<lt>SlaveE<nbsp>/E<gt> blocks, the following options are allowed:

=over 4

=item B<Instance> I<Instance>

Specify the plugin instance to use when dispatching the values to I<collectd>.
By default "slave_I<ID>" is used.

=item B<Collect> I<DataName>

Specifies which data to retrieve from the device. I<DataName> must be the same
string as the I<Name> argument passed to a B<Data> block. You can specify this
option multiple times to collect more than one value from a slave. At least one
B<Collect> option is mandatory.

=back

=back

=back

=head2 Plugin C<mysql>

The C<mysql plugin> requires B<mysqlclient> to be installed. It connects to
one or more databases when started and keeps the connection up as long as
possible. When the connection is interrupted for whatever reason it will try
to re-connect. The plugin will complain loudly in case anything goes wrong.

This plugin issues the MySQL C<SHOW STATUS> / C<SHOW GLOBAL STATUS> command
and collects information about MySQL network traffic, executed statements,
requests, the query cache and threads by evaluating the
C<Bytes_{received,sent}>, C<Com_*>, C<Handler_*>, C<Qcache_*> and C<Threads_*>
return values. Please refer to the B<MySQL reference manual>, I<5.1.6. Server
Status Variables> for an explanation of these values.

Optionally, master and slave statistics may be collected in a MySQL
replication setup. In that case, information about the synchronization state
of the nodes are collected by evaluating the C<Position> return value of the
C<SHOW MASTER STATUS> command and the C<Seconds_Behind_Master>,
C<Read_Master_Log_Pos> and C<Exec_Master_Log_Pos> return values of the
C<SHOW SLAVE STATUS> command. See the B<MySQL reference manual>,
I<12.5.5.21 SHOW MASTER STATUS Syntax> and
I<12.5.5.31 SHOW SLAVE STATUS Syntax> for details.

Synopsis:

  <Plugin mysql>
    <Database foo>
      Host "hostname"
      User "username"
      Password "password"
      Port "3306"
      MasterStats true
    </Database>

    <Database bar>
      Host "localhost"
      Socket "/var/run/mysql/mysqld.sock"
      SlaveStats true
      SlaveNotifications true
    </Database>
  </Plugin>

A B<Database> block defines one connection to a MySQL database. It accepts a
single argument which specifies the name of the database. None of the other
options are required. MySQL will use default values as documented in the
section "mysql_real_connect()" in the B<MySQL reference manual>.

=over 4

=item B<Host> I<Hostname>

Hostname of the database server. Defaults to B<localhost>.

=item B<User> I<Username>

Username to use when connecting to the database. The user does not have to be
granted any privileges (which is synonym to granting the C<USAGE> privilege),
unless you want to collectd replication statistics (see B<MasterStats> and
B<SlaveStats> below). In this case, the user needs the C<REPLICATION CLIENT>
(or C<SUPER>) privileges. Else, any existing MySQL user will do.

=item B<Password> I<Password>

Password needed to log into the database.

=item B<Database> I<Database>

Select this database. Defaults to I<no database> which is a perfectly reasonable
option for what this plugin does.

=item B<Port> I<Port>

TCP-port to connect to. The port must be specified in its numeric form, but it
must be passed as a string nonetheless. For example:

  Port "3306"

If B<Host> is set to B<localhost> (the default), this setting has no effect.
See the documentation for the C<mysql_real_connect> function for details.

=item B<Socket> I<Socket>

Specifies the path to the UNIX domain socket of the MySQL server. This option
only has any effect, if B<Host> is set to B<localhost> (the default).
Otherwise, use the B<Port> option above. See the documentation for the
C<mysql_real_connect> function for details.

=item B<MasterStats> I<true|false>

=item B<SlaveStats> I<true|false>

Enable the collection of master / slave statistics in a replication setup. In
order to be able to get access to these statistics, the user needs special
privileges. See the B<User> documentation above.

=item B<SlaveNotifications> I<true|false>

If enabled, the plugin sends a notification if the replication slave I/O and /
or SQL threads are not running.

=back

=head2 Plugin C<netapp>

The netapp plugin can collect various performance and capacity information
from a NetApp filer using the NetApp API.

Please note that NetApp has a wide line of products and a lot of different
software versions for each of these products. This plugin was developed for a
NetApp FAS3040 running OnTap 7.2.3P8 and tested on FAS2050 7.3.1.1L1,
FAS3140 7.2.5.1 and FAS3020 7.2.4P9. It I<should> work for most combinations of
model and software version but it is very hard to test this.
If you have used this plugin with other models and/or software version, feel
free to send us a mail to tell us about the results, even if it's just a short
"It works".

To collect these data collectd will log in to the NetApp via HTTP(S) and HTTP
basic authentication.

B<Do not use a regular user for this!> Create a special collectd user with just
the minimum of capabilities needed. The user only needs the "login-http-admin"
capability as well as a few more depending on which data will be collected.
Required capabilities are documented below.

=head3 Synopsis

 <Plugin "netapp">
   <Host "netapp1.example.com">
    Protocol      "https"
    Address       "10.0.0.1"
    Port          443
    User          "username"
    Password      "aef4Aebe"
    Interval      30
    
    <WAFL>
      Interval 30
      GetNameCache   true
      GetDirCache    true
      GetBufferCache true
      GetInodeCache  true
    </WAFL>
    
    <Disks>
      Interval 30
      GetBusy true
    </Disks>
    
    <VolumePerf>
      Interval 30
      GetIO      "volume0"
      IgnoreSelectedIO      false
      GetOps     "volume0"
      IgnoreSelectedOps     false
      GetLatency "volume0"
      IgnoreSelectedLatency false
    </VolumePerf>
    
    <VolumeUsage>
      Interval 30
      GetCapacity "vol0"
      GetCapacity "vol1"
      IgnoreSelectedCapacity false
      GetSnapshot "vol1"
      GetSnapshot "vol3"
      IgnoreSelectedSnapshot false
    </VolumeUsage>
    
    <Quota>
      Interval 60
    </Quota>
    
    <Snapvault>
      Interval 30
    </Snapvault>
    
    <System>
      Interval 30
      GetCPULoad     true
      GetInterfaces  true
      GetDiskOps     true
      GetDiskIO      true
    </System>

    <VFiler vfilerA>
      Interval 60

      SnapVault true
      # ...
    </VFiler>
   </Host>
 </Plugin>

The netapp plugin accepts the following configuration options:

=over 4

=item B<Host> I<Name>

A host block defines one NetApp filer. It will appear in collectd with the name
you specify here which does not have to be its real name nor its hostname (see
the B<Address> option below).

=item B<VFiler> I<Name>

A B<VFiler> block may only be used inside a host block. It accepts all the
same options as the B<Host> block (except for cascaded B<VFiler> blocks) and
will execute all NetApp API commands in the context of the specified
VFiler(R). It will appear in collectd with the name you specify here which
does not have to be its real name. The VFiler name may be specified using the
B<VFilerName> option. If this is not specified, it will default to the name
you specify here.

The VFiler block inherits all connection related settings from the surrounding
B<Host> block (which appear before the B<VFiler> block) but they may be
overwritten inside the B<VFiler> block.

This feature is useful, for example, when using a VFiler as SnapVault target
(supported since OnTap 8.1). In that case, the SnapVault statistics are not
available in the host filer (vfiler0) but only in the respective VFiler
context.

=item B<Protocol> B<httpd>|B<http>

The protocol collectd will use to query this host.

Optional

Type: string

Default: https

Valid options: http, https

=item B<Address> I<Address>

The hostname or IP address of the host.

Optional

Type: string

Default: The "host" block's name.

=item B<Port> I<Port>

The TCP port to connect to on the host.

Optional

Type: integer

Default: 80 for protocol "http", 443 for protocol "https"

=item B<User> I<User>

=item B<Password> I<Password>

The username and password to use to login to the NetApp.

Mandatory

Type: string

=item B<VFilerName> I<Name>

The name of the VFiler in which context to execute API commands. If not
specified, the name provided to the B<VFiler> block will be used instead.

Optional

Type: string

Default: name of the B<VFiler> block

B<Note:> This option may only be used inside B<VFiler> blocks.

=item B<Interval> I<Interval>

B<TODO>

=back

The following options decide what kind of data will be collected. You can
either use them as a block and fine tune various parameters inside this block,
use them as a single statement to just accept all default values, or omit it to
not collect any data.

The following options are valid inside all blocks:

=over 4

=item B<Interval> I<Seconds>

Collect the respective statistics every I<Seconds> seconds. Defaults to the
host specific setting.

=back

=head3 The System block

This will collect various performance data about the whole system.

B<Note:> To get this data the collectd user needs the
"api-perf-object-get-instances" capability.

=over 4

=item B<Interval> I<Seconds>

Collect disk statistics every I<Seconds> seconds.

=item B<GetCPULoad> B<true>|B<false>

If you set this option to true the current CPU usage will be read. This will be
the average usage between all CPUs in your NetApp without any information about
individual CPUs.

B<Note:> These are the same values that the NetApp CLI command "sysstat"
returns in the "CPU" field.

Optional

Type: boolean

Default: true

Result: Two value lists of type "cpu", and type instances "idle" and "system".

=item B<GetInterfaces> B<true>|B<false>

If you set this option to true the current traffic of the network interfaces
will be read. This will be the total traffic over all interfaces of your NetApp
without any information about individual interfaces.

B<Note:> This is the same values that the NetApp CLI command "sysstat" returns
in the "Net kB/s" field.

B<Or is it?>

Optional

Type: boolean

Default: true

Result: One value list of type "if_octects".

=item B<GetDiskIO> B<true>|B<false>

If you set this option to true the current IO throughput will be read. This
will be the total IO of your NetApp without any information about individual
disks, volumes or aggregates.

B<Note:> This is the same values that the NetApp CLI command "sysstat" returns
in the "DiskE<nbsp>kB/s" field.

Optional

Type: boolean

Default: true

Result: One value list of type "disk_octets".

=item B<GetDiskOps> B<true>|B<false>

If you set this option to true the current number of HTTP, NFS, CIFS, FCP,
iSCSI, etc. operations will be read. This will be the total number of
operations on your NetApp without any information about individual volumes or
aggregates.

B<Note:> These are the same values that the NetApp CLI command "sysstat"
returns in the "NFS", "CIFS", "HTTP", "FCP" and "iSCSI" fields.

Optional

Type: boolean

Default: true

Result: A variable number of value lists of type "disk_ops_complex". Each type
of operation will result in one value list with the name of the operation as
type instance.

=back

=head3 The WAFL block

This will collect various performance data about the WAFL file system. At the
moment this just means cache performance.

B<Note:> To get this data the collectd user needs the
"api-perf-object-get-instances" capability.

B<Note:> The interface to get these values is classified as "Diagnostics" by
NetApp. This means that it is not guaranteed to be stable even between minor
releases.

=over 4

=item B<Interval> I<Seconds>

Collect disk statistics every I<Seconds> seconds.

=item B<GetNameCache> B<true>|B<false>

Optional

Type: boolean

Default: true

Result: One value list of type "cache_ratio" and type instance
"name_cache_hit".

=item B<GetDirCache> B<true>|B<false>

Optional

Type: boolean

Default: true

Result: One value list of type "cache_ratio" and type instance "find_dir_hit".

=item B<GetInodeCache> B<true>|B<false>

Optional

Type: boolean

Default: true

Result: One value list of type "cache_ratio" and type instance
"inode_cache_hit".

=item B<GetBufferCache> B<true>|B<false>

B<Note:> This is the same value that the NetApp CLI command "sysstat" returns
in the "Cache hit" field.

Optional

Type: boolean

Default: true

Result: One value list of type "cache_ratio" and type instance "buf_hash_hit".

=back

=head3 The Disks block

This will collect performance data about the individual disks in the NetApp.

B<Note:> To get this data the collectd user needs the
"api-perf-object-get-instances" capability.

=over 4

=item B<Interval> I<Seconds>

Collect disk statistics every I<Seconds> seconds.

=item B<GetBusy> B<true>|B<false>

If you set this option to true the busy time of all disks will be calculated
and the value of the busiest disk in the system will be written.

B<Note:> This is the same values that the NetApp CLI command "sysstat" returns
in the "Disk util" field. Probably.

Optional

Type: boolean

Default: true

Result: One value list of type "percent" and type instance "disk_busy".

=back

=head3 The VolumePerf block

This will collect various performance data about the individual volumes.

You can select which data to collect about which volume using the following
options. They follow the standard ignorelist semantic.

B<Note:> To get this data the collectd user needs the
I<api-perf-object-get-instances> capability.

=over 4

=item B<Interval> I<Seconds>

Collect volume performance data every I<Seconds> seconds.

=item B<GetIO> I<Volume>

=item B<GetOps> I<Volume>

=item B<GetLatency> I<Volume>

Select the given volume for IO, operations or latency statistics collection.
The argument is the name of the volume without the C</vol/> prefix.

Since the standard ignorelist functionality is used here, you can use a string
starting and ending with a slash to specify regular expression matching: To
match the volumes "vol0", "vol2" and "vol7", you can use this regular
expression:

  GetIO "/^vol[027]$/"

If no regular expression is specified, an exact match is required. Both,
regular and exact matching are case sensitive.

If no volume was specified at all for either of the three options, that data
will be collected for all available volumes.

=item B<IgnoreSelectedIO> B<true>|B<false>

=item B<IgnoreSelectedOps> B<true>|B<false>

=item B<IgnoreSelectedLatency> B<true>|B<false>

When set to B<true>, the volumes selected for IO, operations or latency
statistics collection will be ignored and the data will be collected for all
other volumes.

When set to B<false>, data will only be collected for the specified volumes and
all other volumes will be ignored.

If no volumes have been specified with the above B<Get*> options, all volumes
will be collected regardless of the B<IgnoreSelected*> option.

Defaults to B<false>

=back

=head3 The VolumeUsage block

This will collect capacity data about the individual volumes.

B<Note:> To get this data the collectd user needs the I<api-volume-list-info>
capability.

=over 4

=item B<Interval> I<Seconds>

Collect volume usage statistics every I<Seconds> seconds.

=item B<GetCapacity> I<VolumeName>

The current capacity of the volume will be collected. This will result in two
to four value lists, depending on the configuration of the volume. All data
sources are of type "df_complex" with the name of the volume as
plugin_instance.

There will be type_instances "used" and "free" for the number of used and
available bytes on the volume.  If the volume has some space reserved for
snapshots, a type_instance "snap_reserved" will be available.  If the volume
has SIS enabled, a type_instance "sis_saved" will be available. This is the
number of bytes saved by the SIS feature.

B<Note:> The current NetApp API has a bug that results in this value being
reported as a 32E<nbsp>bit number. This plugin tries to guess the correct
number which works most of the time.  If you see strange values here, bug
NetApp support to fix this.

Repeat this option to specify multiple volumes.

=item B<IgnoreSelectedCapacity> B<true>|B<false>

Specify whether to collect only the volumes selected by the B<GetCapacity>
option or to ignore those volumes. B<IgnoreSelectedCapacity> defaults to
B<false>. However, if no B<GetCapacity> option is specified at all, all
capacities will be selected anyway.

=item B<GetSnapshot> I<VolumeName>

Select volumes from which to collect snapshot information.

Usually, the space used for snapshots is included in the space reported as
"used". If snapshot information is collected as well, the space used for
snapshots is subtracted from the used space.

To make things even more interesting, it is possible to reserve space to be
used for snapshots. If the space required for snapshots is less than that
reserved space, there is "reserved free" and "reserved used" space in addition
to "free" and "used". If the space required for snapshots exceeds the reserved
space, that part allocated in the normal space is subtracted from the "used"
space again.

Repeat this option to specify multiple volumes.

=item B<IgnoreSelectedSnapshot>

Specify whether to collect only the volumes selected by the B<GetSnapshot>
option or to ignore those volumes. B<IgnoreSelectedSnapshot> defaults to
B<false>. However, if no B<GetSnapshot> option is specified at all, all
capacities will be selected anyway.

=back

=head3 The Quota block

This will collect (tree) quota statistics (used disk space and number of used
files). This mechanism is useful to get usage information for single qtrees.
In case the quotas are not used for any other purpose, an entry similar to the
following in C</etc/quotas> would be sufficient:

  /vol/volA/some_qtree tree - - - - -

After adding the entry, issue C<quota on -w volA> on the NetApp filer.

=over 4

=item B<Interval> I<Seconds>

Collect SnapVault(R) statistics every I<Seconds> seconds.

=back

=head3 The SnapVault block

This will collect statistics about the time and traffic of SnapVault(R)
transfers.

=over 4

=item B<Interval> I<Seconds>

Collect SnapVault(R) statistics every I<Seconds> seconds.

=back

=head2 Plugin C<netlink>

The C<netlink> plugin uses a netlink socket to query the Linux kernel about
statistics of various interface and routing aspects.

=over 4

=item B<Interface> I<Interface>

=item B<VerboseInterface> I<Interface>

Instruct the plugin to collect interface statistics. This is basically the same
as the statistics provided by the C<interface> plugin (see above) but
potentially much more detailed.

When configuring with B<Interface> only the basic statistics will be collected,
namely octets, packets, and errors. These statistics are collected by
the C<interface> plugin, too, so using both at the same time is no benefit.

When configured with B<VerboseInterface> all counters B<except> the basic ones,
so that no data needs to be collected twice if you use the C<interface> plugin.
This includes dropped packets, received multicast packets, collisions and a
whole zoo of differentiated RX and TX errors. You can try the following command
to get an idea of what awaits you:

  ip -s -s link list

If I<Interface> is B<All>, all interfaces will be selected.

=item B<QDisc> I<Interface> [I<QDisc>]

=item B<Class> I<Interface> [I<Class>]

=item B<Filter> I<Interface> [I<Filter>]

Collect the octets and packets that pass a certain qdisc, class or filter.

QDiscs and classes are identified by their type and handle (or classid).
Filters don't necessarily have a handle, therefore the parent's handle is used.
The notation used in collectd differs from that used in tc(1) in that it
doesn't skip the major or minor number if it's zero and doesn't print special
ids by their name. So, for example, a qdisc may be identified by
C<pfifo_fast-1:0> even though the minor number of B<all> qdiscs is zero and
thus not displayed by tc(1).

If B<QDisc>, B<Class>, or B<Filter> is given without the second argument,
i.E<nbsp>.e. without an identifier, all qdiscs, classes, or filters that are
associated with that interface will be collected.

Since a filter itself doesn't necessarily have a handle, the parent's handle is
used. This may lead to problems when more than one filter is attached to a
qdisc or class. This isn't nice, but we don't know how this could be done any
better. If you have a idea, please don't hesitate to tell us.

As with the B<Interface> option you can specify B<All> as the interface,
meaning all interfaces.

Here are some examples to help you understand the above text more easily:

  <Plugin netlink>
    VerboseInterface "All"
    QDisc "eth0" "pfifo_fast-1:0"
    QDisc "ppp0"
    Class "ppp0" "htb-1:10"
    Filter "ppp0" "u32-1:0"
  </Plugin>

=item B<IgnoreSelected>

The behavior is the same as with all other similar plugins: If nothing is
selected at all, everything is collected. If some things are selected using the
options described above, only these statistics are collected. If you set
B<IgnoreSelected> to B<true>, this behavior is inverted, i.E<nbsp>e. the
specified statistics will not be collected.

=back

=head2 Plugin C<network>

The Network plugin sends data to a remote instance of collectd, receives data
from a remote instance, or both at the same time. Data which has been received
from the network is usually not transmitted again, but this can be activated, see
the B<Forward> option below.

The default IPv6 multicast group is C<ff18::efc0:4a42>. The default IPv4
multicast group is C<239.192.74.66>. The default I<UDP> port is B<25826>.

Both, B<Server> and B<Listen> can be used as single option or as block. When
used as block, given options are valid for this socket only. The following
example will export the metrics twice: Once to an "internal" server (without
encryption and signing) and one to an external server (with cryptographic
signature):

 <Plugin "network">
   # Export to an internal server
   # (demonstrates usage without additional options)
   Server "collectd.internal.tld"
   
   # Export to an external server
   # (demonstrates usage with signature options)
   <Server "collectd.external.tld">
     SecurityLevel "sign"
     Username "myhostname"
     Password "ohl0eQue"
   </Server>
 </Plugin>

=over 4

=item B<E<lt>Server> I<Host> [I<Port>]B<E<gt>>

The B<Server> statement/block sets the server to send datagrams to. The
statement may occur multiple times to send each datagram to multiple
destinations.

The argument I<Host> may be a hostname, an IPv4 address or an IPv6 address. The
optional second argument specifies a port number or a service name. If not
given, the default, B<25826>, is used.

The following options are recognized within B<Server> blocks:

=over 4

=item B<SecurityLevel> B<Encrypt>|B<Sign>|B<None>

Set the security you require for network communication. When the security level
has been set to B<Encrypt>, data sent over the network will be encrypted using
I<AES-256>. The integrity of encrypted packets is ensured using I<SHA-1>. When
set to B<Sign>, transmitted data is signed using the I<HMAC-SHA-256> message
authentication code. When set to B<None>, data is sent without any security.

This feature is only available if the I<network> plugin was linked with
I<libgcrypt>.

=item B<Username> I<Username>

Sets the username to transmit. This is used by the server to lookup the
password. See B<AuthFile> below. All security levels except B<None> require
this setting.

This feature is only available if the I<network> plugin was linked with
I<libgcrypt>.

=item B<Password> I<Password>

Sets a password (shared secret) for this socket. All security levels except
B<None> require this setting.

This feature is only available if the I<network> plugin was linked with
I<libgcrypt>.

=item B<Interface> I<Interface name>

Set the outgoing interface for IP packets. This applies at least
to IPv6 packets and if possible to IPv4. If this option is not applicable,
undefined or a non-existent interface name is specified, the default
behavior is to let the kernel choose the appropriate interface. Be warned
that the manual selection of an interface for unicast traffic is only
necessary in rare cases.

=back

=item B<E<lt>Listen> I<Host> [I<Port>]B<E<gt>>

The B<Listen> statement sets the interfaces to bind to. When multiple
statements are found the daemon will bind to multiple interfaces.

The argument I<Host> may be a hostname, an IPv4 address or an IPv6 address. If
the argument is a multicast address the daemon will join that multicast group.
The optional second argument specifies a port number or a service name. If not
given, the default, B<25826>, is used.

The following options are recognized within C<E<lt>ListenE<gt>> blocks:

=over 4

=item B<SecurityLevel> B<Encrypt>|B<Sign>|B<None>

Set the security you require for network communication. When the security level
has been set to B<Encrypt>, only encrypted data will be accepted. The integrity
of encrypted packets is ensured using I<SHA-1>. When set to B<Sign>, only
signed and encrypted data is accepted. When set to B<None>, all data will be
accepted. If an B<AuthFile> option was given (see below), encrypted data is
decrypted if possible.

This feature is only available if the I<network> plugin was linked with
I<libgcrypt>.

=item B<AuthFile> I<Filename>

Sets a file in which usernames are mapped to passwords. These passwords are
used to verify signatures and to decrypt encrypted network packets. If
B<SecurityLevel> is set to B<None>, this is optional. If given, signed data is
verified and encrypted packets are decrypted. Otherwise, signed data is
accepted without checking the signature and encrypted data cannot be decrypted.
For the other security levels this option is mandatory.

The file format is very simple: Each line consists of a username followed by a
colon and any number of spaces followed by the password. To demonstrate, an
example file could look like this:

  user0: foo
  user1: bar

Each time a packet is received, the modification time of the file is checked
using L<stat(2)>. If the file has been changed, the contents is re-read. While
the file is being read, it is locked using L<fcntl(2)>.

=item B<Interface> I<Interface name>

Set the incoming interface for IP packets explicitly. This applies at least
to IPv6 packets and if possible to IPv4. If this option is not applicable,
undefined or a non-existent interface name is specified, the default
behavior is, to let the kernel choose the appropriate interface. Thus incoming
traffic gets only accepted, if it arrives on the given interface.

=back

=item B<TimeToLive> I<1-255>

Set the time-to-live of sent packets. This applies to all, unicast and
multicast, and IPv4 and IPv6 packets. The default is to not change this value.
That means that multicast packets will be sent with a TTL of C<1> (one) on most
operating systems.

=item B<MaxPacketSize> I<1024-65535>

Set the maximum size for datagrams received over the network. Packets larger
than this will be truncated. Defaults to 1452E<nbsp>bytes, which is the maximum
payload size that can be transmitted in one Ethernet frame using IPv6E<nbsp>/
UDP.

On the server side, this limit should be set to the largest value used on
I<any> client. Likewise, the value on the client must not be larger than the
value on the server, or data will be lost.

B<Compatibility:> Versions prior to I<versionE<nbsp>4.8> used a fixed sized
buffer of 1024E<nbsp>bytes. Versions I<4.8>, I<4.9> and I<4.10> used a default
value of 1024E<nbsp>bytes to avoid problems when sending data to an older
server.

=item B<Forward> I<true|false>

If set to I<true>, write packets that were received via the network plugin to
the sending sockets. This should only be activated when the B<Listen>- and
B<Server>-statements differ. Otherwise packets may be send multiple times to
the same multicast group. While this results in more network traffic than
necessary it's not a huge problem since the plugin has a duplicate detection,
so the values will not loop.

=item B<ReportStats> B<true>|B<false>

The network plugin cannot only receive and send statistics, it can also create
statistics about itself. Collected data included the number of received and
sent octets and packets, the length of the receive queue and the number of
values handled. When set to B<true>, the I<Network plugin> will make these
statistics available. Defaults to B<false>.

=back

=head2 Plugin C<nginx>

This plugin collects the number of connections and requests handled by the
C<nginx daemon> (speak: engineE<nbsp>X), a HTTP and mail server/proxy. It
queries the page provided by the C<ngx_http_stub_status_module> module, which
isn't compiled by default. Please refer to
L<http://wiki.codemongers.com/NginxStubStatusModule> for more information on
how to compile and configure nginx and this module.

The following options are accepted by the C<nginx plugin>:

=over 4

=item B<URL> I<http://host/nginx_status>

Sets the URL of the C<ngx_http_stub_status_module> output.

=item B<User> I<Username>

Optional user name needed for authentication.

=item B<Password> I<Password>

Optional password needed for authentication.

=item B<VerifyPeer> B<true|false>

Enable or disable peer SSL certificate verification. See
L<http://curl.haxx.se/docs/sslcerts.html> for details. Enabled by default.

=item B<VerifyHost> B<true|false>

Enable or disable peer host name verification. If enabled, the plugin checks
if the C<Common Name> or a C<Subject Alternate Name> field of the SSL
certificate matches the host name provided by the B<URL> option. If this
identity check fails, the connection is aborted. Obviously, only works when
connecting to a SSL enabled server. Enabled by default.

=item B<CACert> I<File>

File that holds one or more SSL certificates. If you want to use HTTPS you will
possibly need this option. What CA certificates come bundled with C<libcurl>
and are checked by default depends on the distribution you use.

=back

=head2 Plugin C<notify_desktop>

This plugin sends a desktop notification to a notification daemon, as defined
in the Desktop Notification Specification. To actually display the
notifications, B<notification-daemon> is required and B<collectd> has to be
able to access the X server (i.E<nbsp>e., the C<DISPLAY> and C<XAUTHORITY>
environment variables have to be set correctly) and the D-Bus message bus.

The Desktop Notification Specification can be found at
L<http://www.galago-project.org/specs/notification/>.

=over 4

=item B<OkayTimeout> I<timeout>

=item B<WarningTimeout> I<timeout>

=item B<FailureTimeout> I<timeout>

Set the I<timeout>, in milliseconds, after which to expire the notification
for C<OKAY>, C<WARNING> and C<FAILURE> severities respectively. If zero has
been specified, the displayed notification will not be closed at all - the
user has to do so herself. These options default to 5000. If a negative number
has been specified, the default is used as well.

=back

=head2 Plugin C<notify_email>

The I<notify_email> plugin uses the I<ESMTP> library to send notifications to a
configured email address.

I<libESMTP> is available from L<http://www.stafford.uklinux.net/libesmtp/>.

Available configuration options:

=over 4

=item B<From> I<Address>

Email address from which the emails should appear to come from.

Default: C<root@localhost>

=item B<Recipient> I<Address>

Configures the email address(es) to which the notifications should be mailed.
May be repeated to send notifications to multiple addresses.

At least one B<Recipient> must be present for the plugin to work correctly.

=item B<SMTPServer> I<Hostname>

Hostname of the SMTP server to connect to.

Default: C<localhost>

=item B<SMTPPort> I<Port>

TCP port to connect to.

Default: C<25>

=item B<SMTPUser> I<Username>

Username for ASMTP authentication. Optional.

=item B<SMTPPassword> I<Password>

Password for ASMTP authentication. Optional.

=item B<Subject> I<Subject>

Subject-template to use when sending emails. There must be exactly two
string-placeholders in the subject, given in the standard I<printf(3)> syntax,
i.E<nbsp>e. C<%s>. The first will be replaced with the severity, the second
with the hostname.

Default: C<Collectd notify: %s@%s>

=back

=head2 Plugin C<ntpd>

=over 4

=item B<Host> I<Hostname>

Hostname of the host running B<ntpd>. Defaults to B<localhost>.

=item B<Port> I<Port>

UDP-Port to connect to. Defaults to B<123>.

=item B<ReverseLookups> B<true>|B<false>

Sets whether or not to perform reverse lookups on peers. Since the name or
IP-address may be used in a filename it is recommended to disable reverse
lookups. The default is to do reverse lookups to preserve backwards
compatibility, though.

=item B<IncludeUnitID> B<true>|B<false>

When a peer is a refclock, include the unit ID in the I<type instance>.
Defaults to B<false> for backward compatibility.

If two refclock peers use the same driver and this is B<false>, the plugin will
try to write simultaneous measurements from both to the same type instance.
This will result in error messages in the log and only one set of measurements
making it through.

=back

=head2 Plugin C<nut>

=over 4

=item B<UPS> I<upsname>B<@>I<hostname>[B<:>I<port>]

Add a UPS to collect data from. The format is identical to the one accepted by
L<upsc(8)>.

=back

=head2 Plugin C<olsrd>

The I<olsrd> plugin connects to the TCP port opened by the I<txtinfo> plugin of
the Optimized Link State Routing daemon and reads information about the current
state of the meshed network.

The following configuration options are understood:

=over 4

=item B<Host> I<Host>

Connect to I<Host>. Defaults to B<"localhost">.

=item B<Port> I<Port>

Specifies the port to connect to. This must be a string, even if you give the
port as a number rather than a service name. Defaults to B<"2006">.

=item B<CollectLinks> B<No>|B<Summary>|B<Detail>

Specifies what information to collect about links, i.E<nbsp>e. direct
connections of the daemon queried. If set to B<No>, no information is
collected. If set to B<Summary>, the number of links and the average of all
I<link quality> (LQ) and I<neighbor link quality> (NLQ) values is calculated.
If set to B<Detail> LQ and NLQ are collected per link.

Defaults to B<Detail>.

=item B<CollectRoutes> B<No>|B<Summary>|B<Detail>

Specifies what information to collect about routes of the daemon queried. If
set to B<No>, no information is collected. If set to B<Summary>, the number of
routes and the average I<metric> and I<ETX> is calculated. If set to B<Detail>
metric and ETX are collected per route.

Defaults to B<Summary>.

=item B<CollectTopology> B<No>|B<Summary>|B<Detail>

Specifies what information to collect about the global topology. If set to
B<No>, no information is collected. If set to B<Summary>, the number of links
in the entire topology and the average I<link quality> (LQ) is calculated.
If set to B<Detail> LQ and NLQ are collected for each link in the entire topology.

Defaults to B<Summary>.

=back

=head2 Plugin C<onewire>

B<EXPERIMENTAL!> See notes below.

The C<onewire> plugin uses the B<owcapi> library from the B<owfs> project
L<http://owfs.org/> to read sensors connected via the onewire bus.

Currently only temperature sensors (sensors with the family code C<10>,
e.E<nbsp>g. DS1820, DS18S20, DS1920) can be read. If you have other sensors you
would like to have included, please send a sort request to the mailing list.

Hubs (the DS2409 chips) are working, but read the note, why this plugin is
experimental, below.

=over 4

=item B<Device> I<Device>

Sets the device to read the values from. This can either be a "real" hardware
device, such as a serial port or an USB port, or the address of the
L<owserver(1)> socket, usually B<localhost:4304>.

Though the documentation claims to automatically recognize the given address
format, with versionE<nbsp>2.7p4 we had to specify the type explicitly. So
with that version, the following configuration worked for us:

  <Plugin onewire>
    Device "-s localhost:4304"
  </Plugin>

This directive is B<required> and does not have a default value.

=item B<Sensor> I<Sensor>

Selects sensors to collect or to ignore, depending on B<IgnoreSelected>, see
below. Sensors are specified without the family byte at the beginning, to you'd
use C<F10FCA000800>, and B<not> include the leading C<10.> family byte and
point.

=item B<IgnoreSelected> I<true>|I<false>

If no configuration if given, the B<onewire> plugin will collect data from all
sensors found. This may not be practical, especially if sensors are added and
removed regularly. Sometimes, however, it's easier/preferred to collect only
specific sensors or all sensors I<except> a few specified ones. This option
enables you to do that: By setting B<IgnoreSelected> to I<true> the effect of
B<Sensor> is inverted: All selected interfaces are ignored and all other
interfaces are collected.

=item B<Interval> I<Seconds>

Sets the interval in which all sensors should be read. If not specified, the
global B<Interval> setting is used.

=back

B<EXPERIMENTAL!> The C<onewire> plugin is experimental, because it doesn't yet
work with big setups. It works with one sensor being attached to one
controller, but as soon as you throw in a couple more senors and maybe a hub
or two, reading all values will take more than ten seconds (the default
interval). We will probably add some separate thread for reading the sensors
and some cache or something like that, but it's not done yet. We will try to
maintain backwards compatibility in the future, but we can't promise. So in
short: If it works for you: Great! But keep in mind that the config I<might>
change, though this is unlikely. Oh, and if you want to help improving this
plugin, just send a short notice to the mailing list. ThanksE<nbsp>:)

=head2 Plugin C<openvpn>

The OpenVPN plugin reads a status file maintained by OpenVPN and gathers
traffic statistics about connected clients.

To set up OpenVPN to write to the status file periodically, use the
B<--status> option of OpenVPN. Since OpenVPN can write two different formats,
you need to set the required format, too. This is done by setting
B<--status-version> to B<2>.

So, in a nutshell you need:

  openvpn $OTHER_OPTIONS \
    --status "/var/run/openvpn-status" 10 \
    --status-version 2

Available options:

=over 4

=item B<StatusFile> I<File>

Specifies the location of the status file.

=item B<ImprovedNamingSchema> B<true>|B<false>

When enabled, the filename of the status file will be used as plugin instance
and the client's "common name" will be used as type instance. This is required
when reading multiple status files. Enabling this option is recommended, but to
maintain backwards compatibility this option is disabled by default.

=item B<CollectCompression> B<true>|B<false>

Sets whether or not statistics about the compression used by OpenVPN should be
collected. This information is only available in I<single> mode. Enabled by
default.

=item B<CollectIndividualUsers> B<true>|B<false>

Sets whether or not traffic information is collected for each connected client
individually. If set to false, currently no traffic data is collected at all
because aggregating this data in a save manner is tricky. Defaults to B<true>.

=item B<CollectUserCount> B<true>|B<false>

When enabled, the number of currently connected clients or users is collected.
This is especially interesting when B<CollectIndividualUsers> is disabled, but
can be configured independently from that option. Defaults to B<false>.

=back

=head2 Plugin C<oracle>

The "oracle" plugin uses the Oracle® Call Interface I<(OCI)> to connect to an
Oracle® Database and lets you execute SQL statements there. It is very similar
to the "dbi" plugin, because it was written around the same time. See the "dbi"
plugin's documentation above for details.

  <Plugin oracle>
    <Query "out_of_stock">
      Statement "SELECT category, COUNT(*) AS value FROM products WHERE in_stock = 0 GROUP BY category"
      <Result>
        Type "gauge"
        # InstancePrefix "foo"
        InstancesFrom "category"
        ValuesFrom "value"
      </Result>
    </Query>
    <Database "product_information">
      ConnectID "db01"
      Username "oracle"
      Password "secret"
      Query "out_of_stock"
    </Database>
  </Plugin>

=head3 B<Query> blocks

The Query blocks are handled identically to the Query blocks of the "dbi"
plugin. Please see its documentation above for details on how to specify
queries.

=head3 B<Database> blocks

Database blocks define a connection to a database and which queries should be
sent to that database. Each database needs a "name" as string argument in the
starting tag of the block. This name will be used as "PluginInstance" in the
values submitted to the daemon. Other than that, that name is not used.

=over 4

=item B<ConnectID> I<ID>

Defines the "database alias" or "service name" to connect to. Usually, these
names are defined in the file named C<$ORACLE_HOME/network/admin/tnsnames.ora>.

=item B<Host> I<Host>

Hostname to use when dispatching values for this database. Defaults to using
the global hostname of the I<collectd> instance.

=item B<Username> I<Username>

Username used for authentication.

=item B<Password> I<Password>

Password used for authentication.

=item B<Query> I<QueryName>

Associates the query named I<QueryName> with this database connection. The
query needs to be defined I<before> this statement, i.E<nbsp>e. all query
blocks you want to refer to must be placed above the database block you want to
refer to them from.

=back

=head2 Plugin C<perl>

This plugin embeds a Perl-interpreter into collectd and provides an interface
to collectd's plugin system. See L<collectd-perl(5)> for its documentation.

=head2 Plugin C<pinba>

The I<Pinba plugin> receives profiling information from I<Pinba>, an extension
for the I<PHP> interpreter. At the end of executing a script, i.e. after a
PHP-based webpage has been delivered, the extension will send a UDP packet
containing timing information, peak memory usage and so on. The plugin will
wait for such packets, parse them and account the provided information, which
is then dispatched to the daemon once per interval.

Synopsis:

 <Plugin pinba>
   Address "::0"
   Port "30002"
   # Overall statistics for the website.
   <View "www-total">
     Server "www.example.com"
   </View>
   # Statistics for www-a only
   <View "www-a">
     Host "www-a.example.com"
     Server "www.example.com"
   </View>
   # Statistics for www-b only
   <View "www-b">
     Host "www-b.example.com"
     Server "www.example.com"
   </View>
 </Plugin>

The plugin provides the following configuration options:

=over 4

=item B<Address> I<Node>

Configures the address used to open a listening socket. By default, plugin will
bind to the I<any> address C<::0>.

=item B<Port> I<Service>

Configures the port (service) to bind to. By default the default Pinba port
"30002" will be used. The option accepts service names in addition to port
numbers and thus requires a I<string> argument.

=item E<lt>B<View> I<Name>E<gt> block

The packets sent by the Pinba extension include the hostname of the server, the
server name (the name of the virtual host) and the script that was executed.
Using B<View> blocks it is possible to separate the data into multiple groups
to get more meaningful statistics. Each packet is added to all matching groups,
so that a packet may be accounted for more than once.

=over 4

=item B<Host> I<Host>

Matches the hostname of the system the webserver / script is running on. This
will contain the result of the L<gethostname(2)> system call. If not
configured, all hostnames will be accepted.

=item B<Server> I<Server>

Matches the name of the I<virtual host>, i.e. the contents of the
C<$_SERVER["SERVER_NAME"]> variable when within PHP. If not configured, all
server names will be accepted.

=item B<Script> I<Script>

Matches the name of the I<script name>, i.e. the contents of the
C<$_SERVER["SCRIPT_NAME"]> variable when within PHP. If not configured, all
script names will be accepted.

=back

=back

=head2 Plugin C<ping>

The I<Ping> plugin starts a new thread which sends ICMP "ping" packets to the
configured hosts periodically and measures the network latency. Whenever the
C<read> function of the plugin is called, it submits the average latency, the
standard deviation and the drop rate for each host.

Available configuration options:

=over 4

=item B<Host> I<IP-address>

Host to ping periodically. This option may be repeated several times to ping
multiple hosts.

=item B<Interval> I<Seconds>

Sets the interval in which to send ICMP echo packets to the configured hosts.
This is B<not> the interval in which statistics are queries from the plugin but
the interval in which the hosts are "pinged". Therefore, the setting here
should be smaller than or equal to the global B<Interval> setting. Fractional
times, such as "1.24" are allowed.

Default: B<1.0>

=item B<Timeout> I<Seconds>

Time to wait for a response from the host to which an ICMP packet had been
sent. If a reply was not received after I<Seconds> seconds, the host is assumed
to be down or the packet to be dropped. This setting must be smaller than the
B<Interval> setting above for the plugin to work correctly. Fractional
arguments are accepted.

Default: B<0.9>

=item B<TTL> I<0-255>

Sets the Time-To-Live of generated ICMP packets.

=item B<SourceAddress> I<host>

Sets the source address to use. I<host> may either be a numerical network
address or a network hostname.

=item B<Device> I<name>

Sets the outgoing network device to be used. I<name> has to specify an
interface name (e.E<nbsp>g. C<eth0>). This might not be supported by all
operating systems.

=item B<MaxMissed> I<Packets>

Trigger a DNS resolve after the host has not replied to I<Packets> packets. This
enables the use of dynamic DNS services (like dyndns.org) with the ping plugin.

Default: B<-1> (disabled)

=back

=head2 Plugin C<postgresql>

The C<postgresql> plugin queries statistics from PostgreSQL databases. It
keeps a persistent connection to all configured databases and tries to
reconnect if the connection has been interrupted. A database is configured by
specifying a B<Database> block as described below. The default statistics are
collected from PostgreSQL's B<statistics collector> which thus has to be
enabled for this plugin to work correctly. This should usually be the case by
default. See the section "The Statistics Collector" of the B<PostgreSQL
Documentation> for details.

By specifying custom database queries using a B<Query> block as described
below, you may collect any data that is available from some PostgreSQL
database. This way, you are able to access statistics of external daemons
which are available in a PostgreSQL database or use future or special
statistics provided by PostgreSQL without the need to upgrade your collectd
installation.

Starting with version 5.2, the C<postgresql> plugin supports writing data to
PostgreSQL databases as well. This has been implemented in a generic way. You
need to specify an SQL statement which will then be executed by collectd in
order to write the data (see below for details). The benefit of that approach
is that there is no fixed database layout. Rather, the layout may be optimized
for the current setup.

The B<PostgreSQL Documentation> manual can be found at
L<http://www.postgresql.org/docs/manuals/>.

  <Plugin postgresql>
    <Query magic>
      Statement "SELECT magic FROM wizard WHERE host = $1;"
      Param hostname
      <Result>
        Type gauge
        InstancePrefix "magic"
        ValuesFrom magic
      </Result>
    </Query>

    <Query rt36_tickets>
      Statement "SELECT COUNT(type) AS count, type \
                        FROM (SELECT CASE \
                                     WHEN resolved = 'epoch' THEN 'open' \
                                     ELSE 'resolved' END AS type \
                                     FROM tickets) type \
                        GROUP BY type;"
      <Result>
        Type counter
        InstancePrefix "rt36_tickets"
        InstancesFrom "type"
        ValuesFrom "count"
      </Result>
    </Query>

    <Writer sqlstore>
      Statement "SELECT collectd_insert($1, $2, $3, $4, $5, $6, $7, $8, $9);"
      StoreRates true
    </Writer>

    <Database foo>
      Host "hostname"
      Port "5432"
      User "username"
      Password "secret"
      SSLMode "prefer"
      KRBSrvName "kerberos_service_name"
      Query magic
    </Database>

    <Database bar>
      Interval 300
      Service "service_name"
      Query backend # predefined
      Query rt36_tickets
    </Database>

    <Database qux>
      # ...
      Writer sqlstore
      CommitInterval 10
    </Database>
  </Plugin>

The B<Query> block defines one database query which may later be used by a
database definition. It accepts a single mandatory argument which specifies
the name of the query. The names of all queries have to be unique (see the
B<MinVersion> and B<MaxVersion> options below for an exception to this
rule). The following configuration options are available to define the query:

In each B<Query> block, there is one or more B<Result> blocks. B<Result>
blocks define how to handle the values returned from the query. They define
which column holds which value and how to dispatch that value to the daemon.
Multiple B<Result> blocks may be used to extract multiple values from a single
query.

=over 4

=item B<Statement> I<sql query statement>

Specify the I<sql query statement> which the plugin should execute. The string
may contain the tokens B<$1>, B<$2>, etc. which are used to reference the
first, second, etc. parameter. The value of the parameters is specified by the
B<Param> configuration option - see below for details. To include a literal
B<$> character followed by a number, surround it with single quotes (B<'>).

Any SQL command which may return data (such as C<SELECT> or C<SHOW>) is
allowed. Note, however, that only a single command may be used. Semicolons are
allowed as long as a single non-empty command has been specified only.

The returned lines will be handled separately one after another.

=item B<Param> I<hostname>|I<database>|I<username>|I<interval>

Specify the parameters which should be passed to the SQL query. The parameters
are referred to in the SQL query as B<$1>, B<$2>, etc. in the same order as
they appear in the configuration file. The value of the parameter is
determined depending on the value of the B<Param> option as follows:

=over 4

=item I<hostname>

The configured hostname of the database connection. If a UNIX domain socket is
used, the parameter expands to "localhost".

=item I<database>

The name of the database of the current connection.

=item I<instance>

The name of the database plugin instance. See the B<Instance> option of the
database specification below for details.

=item I<username>

The username used to connect to the database.

=item I<interval>

The interval with which this database is queried (as specified by the database
specific or global B<Interval> options).

=back

Please note that parameters are only supported by PostgreSQL's protocol
version 3 and above which was introduced in version 7.4 of PostgreSQL.

=item B<Type> I<type>

The I<type> name to be used when dispatching the values. The type describes
how to handle the data and where to store it. See L<types.db(5)> for more
details on types and their configuration. The number and type of values (as
selected by the B<ValuesFrom> option) has to match the type of the given name.

This option is required inside a B<Result> block.

=item B<InstancePrefix> I<prefix>

=item B<InstancesFrom> I<column0> [I<column1> ...]

Specify how to create the "TypeInstance" for each data set (i.E<nbsp>e. line).
B<InstancePrefix> defines a static prefix that will be prepended to all type
instances. B<InstancesFrom> defines the column names whose values will be used
to create the type instance. Multiple values will be joined together using the
hyphen (C<->) as separation character.

The plugin itself does not check whether or not all built instances are
different. It is your responsibility to assure that each is unique.

Both options are optional. If none is specified, the type instance will be
empty.

=item B<ValuesFrom> I<column0> [I<column1> ...]

Names the columns whose content is used as the actual data for the data sets
that are dispatched to the daemon. How many such columns you need is
determined by the B<Type> setting as explained above. If you specify too many
or not enough columns, the plugin will complain about that and no data will be
submitted to the daemon.

The actual data type, as seen by PostgreSQL, is not that important as long as
it represents numbers. The plugin will automatically cast the values to the
right type if it know how to do that. For that, it uses the L<strtoll(3)> and
L<strtod(3)> functions, so anything supported by those functions is supported
by the plugin as well.

This option is required inside a B<Result> block and may be specified multiple
times. If multiple B<ValuesFrom> options are specified, the columns are read
in the given order.

=item B<MinVersion> I<version>

=item B<MaxVersion> I<version>

Specify the minimum or maximum version of PostgreSQL that this query should be
used with. Some statistics might only be available with certain versions of
PostgreSQL. This allows you to specify multiple queries with the same name but
which apply to different versions, thus allowing you to use the same
configuration in a heterogeneous environment.

The I<version> has to be specified as the concatenation of the major, minor
and patch-level versions, each represented as two-decimal-digit numbers. For
example, version 8.2.3 will become 80203.

=back

The following predefined queries are available (the definitions can be found
in the F<postgresql_default.conf> file which, by default, is available at
C<I<prefix>/share/collectd/>):

=over 4

=item B<backends>

This query collects the number of backends, i.E<nbsp>e. the number of
connected clients.

=item B<transactions>

This query collects the numbers of committed and rolled-back transactions of
the user tables.

=item B<queries>

This query collects the numbers of various table modifications (i.E<nbsp>e.
insertions, updates, deletions) of the user tables.

=item B<query_plans>

This query collects the numbers of various table scans and returned tuples of
the user tables.

=item B<table_states>

This query collects the numbers of live and dead rows in the user tables.

=item B<disk_io>

This query collects disk block access counts for user tables.

=item B<disk_usage>

This query collects the on-disk size of the database in bytes.

=back

In addition, the following detailed queries are available by default. Please
note that each of those queries collects information B<by table>, thus,
potentially producing B<a lot> of data. For details see the description of the
non-by_table queries above.

=over 4

=item B<queries_by_table>

=item B<query_plans_by_table>

=item B<table_states_by_table>

=item B<disk_io_by_table>

=back

The B<Writer> block defines a PostgreSQL writer backend. It accepts a single
mandatory argument specifying the name of the writer. This will then be used
in the B<Database> specification in order to activate the writer instance. The
names of all writers have to be unique. The following options may be
specified:

=over 4

=item B<Statement> I<sql statement>

This mandatory option specifies the SQL statement that will be executed for
each submitted value. A single SQL statement is allowed only. Anything after
the first semicolon will be ignored.

Nine parameters will be passed to the statement and should be specified as
tokens B<$1>, B<$2>, through B<$9> in the statement string. The following
values are made available through those parameters:

=over 4

=item B<$1>

The timestamp of the queried value as a floating point number.

=item B<$2>

The hostname of the queried value.

=item B<$3>

The plugin name of the queried value.

=item B<$4>

The plugin instance of the queried value. This value may be B<NULL> if there
is no plugin instance.

=item B<$5>

The type of the queried value (cf. L<types.db(5)>).

=item B<$6>

The type instance of the queried value. This value may be B<NULL> if there is
no type instance.

=item B<$7>

An array of names for the submitted values (i.E<nbsp>e., the name of the data
sources of the submitted value-list).

=item B<$8>

An array of types for the submitted values (i.E<nbsp>e., the type of the data
sources of the submitted value-list; C<counter>, C<gauge>, ...). Note, that if
B<StoreRates> is enabled (which is the default, see below), all types will be
C<gauge>.

=item B<$9>

An array of the submitted values. The dimensions of the value name and value
arrays match.

=back

In general, it is advisable to create and call a custom function in the
PostgreSQL database for this purpose. Any procedural language supported by
PostgreSQL will do (see chapter "Server Programming" in the PostgreSQL manual
for details).

=item B<StoreRates> B<false>|B<true>

If set to B<true> (the default), convert counter values to rates. If set to
B<false> counter values are stored as is, i.E<nbsp>e. as an increasing integer
number.

=back

The B<Database> block defines one PostgreSQL database for which to collect
statistics. It accepts a single mandatory argument which specifies the
database name. None of the other options are required. PostgreSQL will use
default values as documented in the section "CONNECTING TO A DATABASE" in the
L<psql(1)> manpage. However, be aware that those defaults may be influenced by
the user collectd is run as and special environment variables. See the manpage
for details.

=over 4

=item B<Interval> I<seconds>

Specify the interval with which the database should be queried. The default is
to use the global B<Interval> setting.

=item B<CommitInterval> I<seconds>

This option may be used for database connections which have "writers" assigned
(see above). If specified, it causes a writer to put several updates into a
single transaction. This transaction will last for the specified amount of
time. By default, each update will be executed in a separate transaction. Each
transaction generates a fair amount of overhead which can, thus, be reduced by
activating this option. The draw-back is, that data covering the specified
amount of time will be lost, for example, if a single statement within the
transaction fails or if the database server crashes.

=item B<Host> I<hostname>

Specify the hostname or IP of the PostgreSQL server to connect to. If the
value begins with a slash, it is interpreted as the directory name in which to
look for the UNIX domain socket.

This option is also used to determine the hostname that is associated with a
collected data set. If it has been omitted or either begins with with a slash
or equals B<localhost> it will be replaced with the global hostname definition
of collectd. Any other value will be passed literally to collectd when
dispatching values. Also see the global B<Hostname> and B<FQDNLookup> options.

=item B<Port> I<port>

Specify the TCP port or the local UNIX domain socket file extension of the
server.

=item B<User> I<username>

Specify the username to be used when connecting to the server.

=item B<Password> I<password>

Specify the password to be used when connecting to the server.

=item B<SSLMode> I<disable>|I<allow>|I<prefer>|I<require>

Specify whether to use an SSL connection when contacting the server. The
following modes are supported:

=item B<Instance> I<name>

Specify the plugin instance name that should be used instead of the database
name (which is the default, if this option has not been specified). This
allows to query multiple databases of the same name on the same host (e.g.
when running multiple database server versions in parallel).

=over 4

=item I<disable>

Do not use SSL at all.

=item I<allow>

First, try to connect without using SSL. If that fails, try using SSL.

=item I<prefer> (default)

First, try to connect using SSL. If that fails, try without using SSL.

=item I<require>

Use SSL only.

=back

=item B<KRBSrvName> I<kerberos_service_name>

Specify the Kerberos service name to use when authenticating with Kerberos 5
or GSSAPI. See the sections "Kerberos authentication" and "GSSAPI" of the
B<PostgreSQL Documentation> for details.

=item B<Service> I<service_name>

Specify the PostgreSQL service name to use for additional parameters. That
service has to be defined in F<pg_service.conf> and holds additional
connection parameters. See the section "The Connection Service File" in the
B<PostgreSQL Documentation> for details.

=item B<Query> I<query>

Specifies a I<query> which should be executed in the context of the database
connection. This may be any of the predefined or user-defined queries. If no
such option is given, it defaults to "backends", "transactions", "queries",
"query_plans", "table_states", "disk_io" and "disk_usage" (unless a B<Writer>
has been specified). Else, the specified queries are used only.

=item B<Writer> I<writer>

Assigns the specified I<writer> backend to the database connection. This
causes all collected data to be send to the database using the settings
defined in the writer configuration (see the section "FILTER CONFIGURATION"
below for details on how to selectively send data to certain plugins).

Each writer will register a flush callback which may be used when having long
transactions enabled (see the B<CommitInterval> option above). When issuing
the B<FLUSH> command (see L<collectd-unixsock(5)> for details) the current
transaction will be committed right away. Two different kinds of flush
callbacks are available with the C<postgresql> plugin:

=over 4

=item B<postgresql>

Flush all writer backends.

=item B<postgresql->I<database>

Flush all writers of the specified I<database> only.

=back

=back

=head2 Plugin C<powerdns>

The C<powerdns> plugin queries statistics from an authoritative PowerDNS
nameserver and/or a PowerDNS recursor. Since both offer a wide variety of
values, many of which are probably meaningless to most users, but may be useful
for some. So you may chose which values to collect, but if you don't, some
reasonable defaults will be collected.

  <Plugin "powerdns">
    <Server "server_name">
      Collect "latency"
      Collect "udp-answers" "udp-queries"
      Socket "/var/run/pdns.controlsocket"
    </Server>
    <Recursor "recursor_name">
      Collect "questions"
      Collect "cache-hits" "cache-misses"
      Socket "/var/run/pdns_recursor.controlsocket"
    </Recursor>
    LocalSocket "/opt/collectd/var/run/collectd-powerdns"
  </Plugin>

=over 4

=item B<Server> and B<Recursor> block

The B<Server> block defines one authoritative server to query, the B<Recursor>
does the same for an recursing server. The possible options in both blocks are
the same, though. The argument defines a name for the serverE<nbsp>/ recursor
and is required.

=over 4

=item B<Collect> I<Field>

Using the B<Collect> statement you can select which values to collect. Here,
you specify the name of the values as used by the PowerDNS servers, e.E<nbsp>g.
C<dlg-only-drops>, C<answers10-100>.

The method of getting the values differs for B<Server> and B<Recursor> blocks:
When querying the server a C<SHOW *> command is issued in any case, because
that's the only way of getting multiple values out of the server at once.
collectd then picks out the values you have selected. When querying the
recursor, a command is generated to query exactly these values. So if you
specify invalid fields when querying the recursor, a syntax error may be
returned by the daemon and collectd may not collect any values at all.

If no B<Collect> statement is given, the following B<Server> values will be
collected:

=over 4

=item latency

=item packetcache-hit

=item packetcache-miss

=item packetcache-size

=item query-cache-hit

=item query-cache-miss

=item recursing-answers

=item recursing-questions

=item tcp-answers

=item tcp-queries

=item udp-answers

=item udp-queries

=back

The following B<Recursor> values will be collected by default:

=over 4

=item noerror-answers

=item nxdomain-answers

=item servfail-answers

=item sys-msec

=item user-msec

=item qa-latency

=item cache-entries

=item cache-hits

=item cache-misses

=item questions

=back

Please note that up to that point collectd doesn't know what values are
available on the server and values that are added do not need a change of the
mechanism so far. However, the values must be mapped to collectd's naming
scheme, which is done using a lookup table that lists all known values. If
values are added in the future and collectd does not know about them, you will
get an error much like this:

  powerdns plugin: submit: Not found in lookup table: foobar = 42

In this case please file a bug report with the collectd team.

=item B<Socket> I<Path>

Configures the path to the UNIX domain socket to be used when connecting to the
daemon. By default C<${localstatedir}/run/pdns.controlsocket> will be used for
an authoritative server and C<${localstatedir}/run/pdns_recursor.controlsocket>
will be used for the recursor.

=back

=item B<LocalSocket> I<Path>

Querying the recursor is done using UDP. When using UDP over UNIX domain
sockets, the client socket needs a name in the file system, too. You can set
this local name to I<Path> using the B<LocalSocket> option. The default is
C<I<prefix>/var/run/collectd-powerdns>.

=back

=head2 Plugin C<processes>

=over 4

=item B<Process> I<Name>

Select more detailed statistics of processes matching this name. The statistics
collected for these selected processes are size of the resident segment size
(RSS), user- and system-time used, number of processes and number of threads,
io data (where available) and minor and major pagefaults.

=item B<ProcessMatch> I<name> I<regex>

Similar to the B<Process> option this allows to select more detailed
statistics of processes matching the specified I<regex> (see L<regex(7)> for
details). The statistics of all matching processes are summed up and
dispatched to the daemon using the specified I<name> as an identifier. This
allows to "group" several processes together. I<name> must not contain
slashes.

=back

=head2 Plugin C<protocols>

Collects a lot of information about various network protocols, such as I<IP>,
I<TCP>, I<UDP>, etc.

Available configuration options:

=over 4

=item B<Value> I<Selector>

Selects whether or not to select a specific value. The string being matched is
of the form "I<Protocol>:I<ValueName>", where I<Protocol> will be used as the
plugin instance and I<ValueName> will be used as type instance. An example of
the string being used would be C<Tcp:RetransSegs>.

You can use regular expressions to match a large number of values with just one
configuration option. To select all "extended" I<TCP> values, you could use the
following statement:

  Value "/^TcpExt:/"

Whether only matched values are selected or all matched values are ignored
depends on the B<IgnoreSelected>. By default, only matched values are selected.
If no value is configured at all, all values will be selected.

=item B<IgnoreSelected> B<true>|B<false>

If set to B<true>, inverts the selection made by B<Value>, i.E<nbsp>e. all
matching values will be ignored.

=back

=head2 Plugin C<python>

This plugin embeds a Python-interpreter into collectd and provides an interface
to collectd's plugin system. See L<collectd-python(5)> for its documentation.

=head2 Plugin C<routeros>

The C<routeros> plugin connects to a device running I<RouterOS>, the
Linux-based operating system for routers by I<MikroTik>. The plugin uses
I<librouteros> to connect and reads information about the interfaces and
wireless connections of the device. The configuration supports querying
multiple routers:

  <Plugin "routeros">
    <Router>
      Host "router0.example.com"
      User "collectd"
      Password "secr3t"
      CollectInterface true
      CollectCPULoad true
      CollectMemory true
    </Router>
    <Router>
      Host "router1.example.com"
      User "collectd"
      Password "5ecret"
      CollectInterface true
      CollectRegistrationTable true
      CollectDF true
      CollectDisk true
    </Router>
  </Plugin>

As you can see above, the configuration of the I<routeros> plugin consists of
one or more B<E<lt>RouterE<gt>> blocks. Within each block, the following
options are understood:

=over 4

=item B<Host> I<Host>

Hostname or IP-address of the router to connect to.

=item B<Port> I<Port>

Port name or port number used when connecting. If left unspecified, the default
will be chosen by I<librouteros>, currently "8728". This option expects a
string argument, even when a numeric port number is given.

=item B<User> I<User>

Use the user name I<User> to authenticate. Defaults to "admin".

=item B<Password> I<Password>

Set the password used to authenticate.

=item B<CollectInterface> B<true>|B<false>

When set to B<true>, interface statistics will be collected for all interfaces
present on the device. Defaults to B<false>.

=item B<CollectRegistrationTable> B<true>|B<false>

When set to B<true>, information about wireless LAN connections will be
collected. Defaults to B<false>.

=item B<CollectCPULoad> B<true>|B<false>

When set to B<true>, information about the CPU usage will be collected. The
number is a dimensionless value where zero indicates no CPU usage at all.
Defaults to B<false>.

=item B<CollectMemory> B<true>|B<false>

When enabled, the amount of used and free memory will be collected. How used
memory is calculated is unknown, for example whether or not caches are counted
as used space.
Defaults to B<false>.

=item B<CollectDF> B<true>|B<false>

When enabled, the amount of used and free disk space will be collected.
Defaults to B<false>.

=item B<CollectDisk> B<true>|B<false>

When enabled, the number of sectors written and bad blocks will be collected.
Defaults to B<false>.

=back

=head2 Plugin C<redis>

The I<Redis plugin> connects to one or more Redis servers and gathers
information about each server's state. For each server there is a I<Node> block
which configures the connection parameters for this node.

  <Plugin redis>
    <Node "example">
        Host "localhost"
        Port "6379"
        Timeout 2000
    </Node>
  </Plugin>

The information shown in the synopsis above is the I<default configuration>
which is used by the plugin if no configuration is present.

=over 4

=item B<Node> I<Nodename>

The B<Node> block identifies a new Redis node, that is a new Redis instance
running in an specified host and port. The name for node is a canonical
identifier which is used as I<plugin instance>. It is limited to
64E<nbsp>characters in length.

=item B<Host> I<Hostname>

The B<Host> option is the hostname or IP-address where the Redis instance is
running on.

=item B<Port> I<Port>

The B<Port> option is the TCP port on which the Redis instance accepts
connections. Either a service name of a port number may be given. Please note
that numerical port numbers must be given as a string, too.

=item B<Password> I<Password>

Use I<Password> to authenticate when connecting to I<Redis>.

=item B<Timeout> I<Timeout in miliseconds>

The B<Timeout> option set the socket timeout for node response. Since the Redis
read function is blocking, you should keep this value as low as possible. Keep
in mind that the sum of all B<Timeout> values for all B<Nodes> should be lower
than B<Interval> defined globally.

=back

=head2 Plugin C<rrdcached>

The C<rrdcached> plugin uses the RRDtool accelerator daemon, L<rrdcached(1)>,
to store values to RRD files in an efficient manner. The combination of the
C<rrdcached> B<plugin> and the C<rrdcached> B<daemon> is very similar to the
way the C<rrdtool> plugin works (see below). The added abstraction layer
provides a number of benefits, though: Because the cache is not within
C<collectd> anymore, it does not need to be flushed when C<collectd> is to be
restarted. This results in much shorter (if any) gaps in graphs, especially
under heavy load. Also, the C<rrdtool> command line utility is aware of the
daemon so that it can flush values to disk automatically when needed. This
allows to integrate automated flushing of values into graphing solutions much
more easily.

There are disadvantages, though: The daemon may reside on a different host, so
it may not be possible for C<collectd> to create the appropriate RRD files
anymore. And even if C<rrdcached> runs on the same host, it may run in a
different base directory, so relative paths may do weird stuff if you're not
careful.

So the B<recommended configuration> is to let C<collectd> and C<rrdcached> run
on the same host, communicating via a UNIX domain socket. The B<DataDir>
setting should be set to an absolute path, so that a changed base directory
does not result in RRD files being createdE<nbsp>/ expected in the wrong place.

=over 4

=item B<DaemonAddress> I<Address>

Address of the daemon as understood by the C<rrdc_connect> function of the RRD
library. See L<rrdcached(1)> for details. Example:

  <Plugin "rrdcached">
    DaemonAddress "unix:/var/run/rrdcached.sock"
  </Plugin>

=item B<DataDir> I<Directory>

Set the base directory in which the RRD files reside. If this is a relative
path, it is relative to the working base directory of the C<rrdcached> daemon!
Use of an absolute path is recommended.

=item B<CreateFiles> B<true>|B<false>

Enables or disables the creation of RRD files. If the daemon is not running
locally, or B<DataDir> is set to a relative path, this will not work as
expected. Default is B<true>.

=item B<CreateFilesAsync> B<false>|B<true>

When enabled, new RRD files are enabled asynchronously, using a separate thread
that runs in the background. This prevents writes to block, which is a problem
especially when many hundreds of files need to be created at once. However,
since the purpose of creating the files asynchronously is I<not> to block until
the file is available, values before the file is available will be discarded.
When disabled (the default) files are created synchronously, blocking for a
short while, while the file is being written.

=item B<StepSize> I<Seconds>

B<Force> the stepsize of newly created RRD-files. Ideally (and per default)
this setting is unset and the stepsize is set to the interval in which the data
is collected. Do not use this option unless you absolutely have to for some
reason. Setting this option may cause problems with the C<snmp plugin>, the
C<exec plugin> or when the daemon is set up to receive data from other hosts.

=item B<HeartBeat> I<Seconds>

B<Force> the heartbeat of newly created RRD-files. This setting should be unset
in which case the heartbeat is set to twice the B<StepSize> which should equal
the interval in which data is collected. Do not set this option unless you have
a very good reason to do so.

=item B<RRARows> I<NumRows>

The C<rrdtool plugin> calculates the number of PDPs per CDP based on the
B<StepSize>, this setting and a timespan. This plugin creates RRD-files with
three times five RRAs, i. e. five RRAs with the CFs B<MIN>, B<AVERAGE>, and
B<MAX>. The five RRAs are optimized for graphs covering one hour, one day, one
week, one month, and one year.

So for each timespan, it calculates how many PDPs need to be consolidated into
one CDP by calculating:
  number of PDPs = timespan / (stepsize * rrarows)

Bottom line is, set this no smaller than the width of you graphs in pixels. The
default is 1200.

=item B<RRATimespan> I<Seconds>

Adds an RRA-timespan, given in seconds. Use this option multiple times to have
more then one RRA. If this option is never used, the built-in default of (3600,
86400, 604800, 2678400, 31622400) is used.

For more information on how RRA-sizes are calculated see B<RRARows> above.

=item B<XFF> I<Factor>

Set the "XFiles Factor". The default is 0.1. If unsure, don't set this option.
I<Factor> must be in the range C<[0.0-1.0)>, i.e. between zero (inclusive) and
one (exclusive).

=back

=head2 Plugin C<rrdtool>

You can use the settings B<StepSize>, B<HeartBeat>, B<RRARows>, and B<XFF> to
fine-tune your RRD-files. Please read L<rrdcreate(1)> if you encounter problems
using these settings. If you don't want to dive into the depths of RRDtool, you
can safely ignore these settings.

=over 4

=item B<DataDir> I<Directory>

Set the directory to store RRD files under. By default RRD files are generated
beneath the daemon's working directory, i.e. the B<BaseDir>.

=item B<CreateFilesAsync> B<false>|B<true>

When enabled, new RRD files are enabled asynchronously, using a separate thread
that runs in the background. This prevents writes to block, which is a problem
especially when many hundreds of files need to be created at once. However,
since the purpose of creating the files asynchronously is I<not> to block until
the file is available, values before the file is available will be discarded.
When disabled (the default) files are created synchronously, blocking for a
short while, while the file is being written.

=item B<StepSize> I<Seconds>

B<Force> the stepsize of newly created RRD-files. Ideally (and per default)
this setting is unset and the stepsize is set to the interval in which the data
is collected. Do not use this option unless you absolutely have to for some
reason. Setting this option may cause problems with the C<snmp plugin>, the
C<exec plugin> or when the daemon is set up to receive data from other hosts.

=item B<HeartBeat> I<Seconds>

B<Force> the heartbeat of newly created RRD-files. This setting should be unset
in which case the heartbeat is set to twice the B<StepSize> which should equal
the interval in which data is collected. Do not set this option unless you have
a very good reason to do so.

=item B<RRARows> I<NumRows>

The C<rrdtool plugin> calculates the number of PDPs per CDP based on the
B<StepSize>, this setting and a timespan. This plugin creates RRD-files with
three times five RRAs, i.e. five RRAs with the CFs B<MIN>, B<AVERAGE>, and
B<MAX>. The five RRAs are optimized for graphs covering one hour, one day, one
week, one month, and one year.

So for each timespan, it calculates how many PDPs need to be consolidated into
one CDP by calculating:
  number of PDPs = timespan / (stepsize * rrarows)

Bottom line is, set this no smaller than the width of you graphs in pixels. The
default is 1200.

=item B<RRATimespan> I<Seconds>

Adds an RRA-timespan, given in seconds. Use this option multiple times to have
more then one RRA. If this option is never used, the built-in default of (3600,
86400, 604800, 2678400, 31622400) is used.

For more information on how RRA-sizes are calculated see B<RRARows> above.

=item B<XFF> I<Factor>

Set the "XFiles Factor". The default is 0.1. If unsure, don't set this option.
I<Factor> must be in the range C<[0.0-1.0)>, i.e. between zero (inclusive) and
one (exclusive).

=item B<CacheFlush> I<Seconds>

When the C<rrdtool> plugin uses a cache (by setting B<CacheTimeout>, see below)
it writes all values for a certain RRD-file if the oldest value is older than
(or equal to) the number of seconds specified. If some RRD-file is not updated
anymore for some reason (the computer was shut down, the network is broken,
etc.) some values may still be in the cache. If B<CacheFlush> is set, then the
entire cache is searched for entries older than B<CacheTimeout> seconds and
written to disk every I<Seconds> seconds. Since this is kind of expensive and
does nothing under normal circumstances, this value should not be too small.
900 seconds might be a good value, though setting this to 7200 seconds doesn't
normally do much harm either.

=item B<CacheTimeout> I<Seconds>

If this option is set to a value greater than zero, the C<rrdtool plugin> will
save values in a cache, as described above. Writing multiple values at once
reduces IO-operations and thus lessens the load produced by updating the files.
The trade off is that the graphs kind of "drag behind" and that more memory is
used.

=item B<WritesPerSecond> I<Updates>

When collecting many statistics with collectd and the C<rrdtool> plugin, you
will run serious performance problems. The B<CacheFlush> setting and the
internal update queue assert that collectd continues to work just fine even
under heavy load, but the system may become very unresponsive and slow. This is
a problem especially if you create graphs from the RRD files on the same
machine, for example using the C<graph.cgi> script included in the
C<contrib/collection3/> directory.

This setting is designed for very large setups. Setting this option to a value
between 25 and 80 updates per second, depending on your hardware, will leave
the server responsive enough to draw graphs even while all the cached values
are written to disk. Flushed values, i.E<nbsp>e. values that are forced to disk
by the B<FLUSH> command, are B<not> effected by this limit. They are still
written as fast as possible, so that web frontends have up to date data when
generating graphs.

For example: If you have 100,000 RRD files and set B<WritesPerSecond> to 30
updates per second, writing all values to disk will take approximately
56E<nbsp>minutes. Together with the flushing ability that's integrated into
"collection3" you'll end up with a responsive and fast system, up to date
graphs and basically a "backup" of your values every hour.

=item B<RandomTimeout> I<Seconds>

When set, the actual timeout for each value is chosen randomly between
I<CacheTimeout>-I<RandomTimeout> and I<CacheTimeout>+I<RandomTimeout>. The
intention is to avoid high load situations that appear when many values timeout
at the same time. This is especially a problem shortly after the daemon starts,
because all values were added to the internal cache at roughly the same time.

=back

=head2 Plugin C<sensors>

The I<Sensors plugin> uses B<lm_sensors> to retrieve sensor-values. This means
that all the needed modules have to be loaded and lm_sensors has to be
configured (most likely by editing F</etc/sensors.conf>. Read
L<sensors.conf(5)> for details.

The B<lm_sensors> homepage can be found at
L<http://secure.netroedge.com/~lm78/>.

=over 4

=item B<SensorConfigFile> I<File>

Read the I<lm_sensors> configuration from I<File>. When unset (recommended),
the library's default will be used.

=item B<Sensor> I<chip-bus-address/type-feature>

Selects the name of the sensor which you want to collect or ignore, depending
on the B<IgnoreSelected> below. For example, the option "B<Sensor>
I<it8712-isa-0290/voltage-in1>" will cause collectd to gather data for the
voltage sensor I<in1> of the I<it8712> on the isa bus at the address 0290.

=item B<IgnoreSelected> I<true>|I<false>

If no configuration if given, the B<sensors>-plugin will collect data from all
sensors. This may not be practical, especially for uninteresting sensors.
Thus, you can use the B<Sensor>-option to pick the sensors you're interested
in. Sometimes, however, it's easier/preferred to collect all sensors I<except> a
few ones. This option enables you to do that: By setting B<IgnoreSelected> to
I<true> the effect of B<Sensor> is inverted: All selected sensors are ignored
and all other sensors are collected.

=back

=head2 Plugin C<sigrok>

The I<sigrok plugin> uses I<libsigrok> to retrieve measurements from any device
supported by the L<sigrok|http://sigrok.org/> project.

B<Synopsis>

 <Plugin sigrok>
   LogLevel 3
   <Device "AC Voltage">
      Driver "fluke-dmm"
      MinimumInterval 10
      Conn "/dev/ttyUSB2"
   </Device>
   <Device "Sound Level">
      Driver "cem-dt-885x"
      Conn "/dev/ttyUSB1"
   </Device>
 </Plugin>

=over 4

=item B<LogLevel> B<0-5>

The I<sigrok> logging level to pass on to the I<collectd> log, as a number
between B<0> and B<5> (inclusive). These levels correspond to C<None>,
C<Errors>, C<Warnings>, C<Informational>, C<Debug >and C<Spew>, respectively.
The default is B<2> (C<Warnings>). The I<sigrok> log messages, regardless of
their level, are always submitted to I<collectd> at its INFO log level.

=item E<lt>B<Device> I<Name>E<gt>

A sigrok-supported device, uniquely identified by this section's options. The
I<Name> is passed to I<collectd> as the I<plugin instance>.

=item B<Driver> I<DriverName>

The sigrok driver to use for this device.

=item B<Conn> I<ConnectionSpec>

If the device cannot be auto-discovered, or more than one might be discovered
by the driver, I<ConnectionSpec> specifies the connection string to the device.
It can be of the form of a device path (e.g.E<nbsp>C</dev/ttyUSB2>), or, in
case of a non-serial USB-connected device, the USB I<VendorID>B<.>I<ProductID>
separated by a period (e.g.E<nbsp>C<0403.6001>). A USB device can also be
specified as I<Bus>B<.>I<Address> (e.g.E<nbsp>C<1.41>).

=item B<SerialComm> I<SerialSpec>

For serial devices with non-standard port settings, this option can be used
to specify them in a form understood by I<sigrok>, e.g.E<nbsp>C<9600/8n1>.
This should not be necessary; drivers know how to communicate with devices they
support.

=item B<MinimumInterval> I<Seconds>

Specifies the minimum time between measurement dispatches to I<collectd>, in
seconds. Since some I<sigrok> supported devices can acquire measurements many
times per second, it may be necessary to throttle these. For example, the
I<RRD plugin> cannot process writes more than once per second.

The default B<MinimumInterval> is B<0>, meaning measurements received from the
device are always dispatched to I<collectd>. When throttled, unused
measurements are discarded.

=back

=head2 Plugin C<snmp>

Since the configuration of the C<snmp plugin> is a little more complicated than
other plugins, its documentation has been moved to an own manpage,
L<collectd-snmp(5)>. Please see there for details.

=head2 Plugin C<statsd>

The I<statsd plugin> listens to a UDP socket, reads "events" in the statsd
protocol and dispatches rates or other aggregates of these numbers
periodically.

The plugin implements the I<Counter>, I<Timer>, I<Gauge> and I<Set> types which
are dispatched as the I<collectd> types C<derive>, C<latency>, C<gauge> and
C<objects> respectively.

The following configuration options are valid:

=over 4

=item B<Host> I<Host>

Bind to the hostname / address I<Host>. By default, the plugin will bind to the
"any" address, i.e. accept packets sent to any of the hosts addresses.

=item B<Port> I<Port>

UDP port to listen to. This can be either a service name or a port number.
Defaults to C<8125>.

=item B<DeleteCounters> B<false>|B<true>

=item B<DeleteTimers> B<false>|B<true>

=item B<DeleteGauges> B<false>|B<true>

=item B<DeleteSets> B<false>|B<true>

These options control what happens if metrics are not updated in an interval.
If set to B<False>, the default, metrics are dispatched unchanged, i.e. the
rate of counters and size of sets will be zero, timers report C<NaN> and gauges
are unchanged. If set to B<True>, the such metrics are not dispatched and
removed from the internal cache.

=item B<TimerPercentile> I<Percent>

Calculate and dispatch the configured percentile, i.e. compute the latency, so
that I<Percent> of all reported timers are smaller than or equal to the
computed latency. This is useful for cutting off the long tail latency, as it's
often done in I<Service Level Agreements> (SLAs).

If not specified, no percentile is calculated / dispatched.

=back

=head2 Plugin C<swap>

The I<Swap plugin> collects information about used and available swap space. On
I<Linux> and I<Solaris>, the following options are available:

=over 4

=item B<ReportByDevice> B<false>|B<true>

Configures how to report physical swap devices. If set to B<false> (the
default), the summary over all swap devices is reported only, i.e. the globally
used and available space over all devices. If B<true> is configured, the used
and available space of each device will be reported separately.

This option is only available if the I<Swap plugin> can read C</proc/swaps>
(under Linux) or use the L<swapctl(2)> mechanism (under I<Solaris>).

=item B<ReportBytes> B<false>|B<true>

When enabled, the I<swap I/O> is reported in bytes. When disabled, the default,
I<swap I/O> is reported in pages. This option is available under Linux only.

=item B<ValuesAbsolute> B<true>|B<false>

Enables or disables reporting of absolute swap metrics, i.e. number of I<bytes>
available and used. Defaults to B<true>.

=item B<ValuesPercentage> B<false>|B<true>

Enables or disables reporting of relative swap metrics, i.e. I<percent>
available and free. Defaults to B<false>.

This is useful for deploying I<collectd> in a heterogeneous environment, where
swap sizes differ and you want to specify generic thresholds or similar.

=back

=head2 Plugin C<syslog>

=over 4

=item B<LogLevel> B<debug|info|notice|warning|err>

Sets the log-level. If, for example, set to B<notice>, then all events with
severity B<notice>, B<warning>, or B<err> will be submitted to the
syslog-daemon.

Please note that B<debug> is only available if collectd has been compiled with
debugging support.

=item B<NotifyLevel> B<OKAY>|B<WARNING>|B<FAILURE>

Controls which notifications should be sent to syslog. The default behaviour is
not to send any. Less severe notifications always imply logging more severe
notifications: Setting this to B<OKAY> means all notifications will be sent to
syslog, setting this to B<WARNING> will send B<WARNING> and B<FAILURE>
notifications but will dismiss B<OKAY> notifications. Setting this option to
B<FAILURE> will only send failures to syslog.

=back

=head2 Plugin C<table>

The C<table plugin> provides generic means to parse tabular data and dispatch
user specified values. Values are selected based on column numbers. For
example, this plugin may be used to get values from the Linux L<proc(5)>
filesystem or CSV (comma separated values) files.

  <Plugin table>
    <Table "/proc/slabinfo">
      Instance "slabinfo"
      Separator " "
      <Result>
        Type gauge
        InstancePrefix "active_objs"
        InstancesFrom 0
        ValuesFrom 1
      </Result>
      <Result>
        Type gauge
        InstancePrefix "objperslab"
        InstancesFrom 0
        ValuesFrom 4
      </Result>
    </Table>
  </Plugin>

The configuration consists of one or more B<Table> blocks, each of which
configures one file to parse. Within each B<Table> block, there are one or
more B<Result> blocks, which configure which data to select and how to
interpret it.

The following options are available inside a B<Table> block:

=over 4

=item B<Instance> I<instance>

If specified, I<instance> is used as the plugin instance. So, in the above
example, the plugin name C<table-slabinfo> would be used. If omitted, the
filename of the table is used instead, with all special characters replaced
with an underscore (C<_>).

=item B<Separator> I<string>

Any character of I<string> is interpreted as a delimiter between the different
columns of the table. A sequence of two or more contiguous delimiters in the
table is considered to be a single delimiter, i.E<nbsp>e. there cannot be any
empty columns. The plugin uses the L<strtok_r(3)> function to parse the lines
of a table - see its documentation for more details. This option is mandatory.

A horizontal tab, newline and carriage return may be specified by C<\\t>,
C<\\n> and C<\\r> respectively. Please note that the double backslashes are
required because of collectd's config parsing.

=back

The following options are available inside a B<Result> block:

=over 4

=item B<Type> I<type>

Sets the type used to dispatch the values to the daemon. Detailed information
about types and their configuration can be found in L<types.db(5)>. This
option is mandatory.

=item B<InstancePrefix> I<prefix>

If specified, prepend I<prefix> to the type instance. If omitted, only the
B<InstancesFrom> option is considered for the type instance.

=item B<InstancesFrom> I<column0> [I<column1> ...]

If specified, the content of the given columns (identified by the column
number starting at zero) will be used to create the type instance for each
row. Multiple values (and the instance prefix) will be joined together with
dashes (I<->) as separation character. If omitted, only the B<InstancePrefix>
option is considered for the type instance.

The plugin itself does not check whether or not all built instances are
different. It’s your responsibility to assure that each is unique. This is
especially true, if you do not specify B<InstancesFrom>: B<You> have to make
sure that the table only contains one row.

If neither B<InstancePrefix> nor B<InstancesFrom> is given, the type instance
will be empty.

=item B<ValuesFrom> I<column0> [I<column1> ...]

Specifies the columns (identified by the column numbers starting at zero)
whose content is used as the actual data for the data sets that are dispatched
to the daemon. How many such columns you need is determined by the B<Type>
setting above. If you specify too many or not enough columns, the plugin will
complain about that and no data will be submitted to the daemon. The plugin
uses L<strtoll(3)> and L<strtod(3)> to parse counter and gauge values
respectively, so anything supported by those functions is supported by the
plugin as well. This option is mandatory.

=back

=head2 Plugin C<tail>

The C<tail plugin> follows logfiles, just like L<tail(1)> does, parses
each line and dispatches found values. What is matched can be configured by the
user using (extended) regular expressions, as described in L<regex(7)>.

  <Plugin "tail">
    <File "/var/log/exim4/mainlog">
      Instance "exim"
      <Match>
        Regex "S=([1-9][0-9]*)"
        DSType "CounterAdd"
        Type "ipt_bytes"
        Instance "total"
      </Match>
      <Match>
        Regex "\\<R=local_user\\>"
        ExcludeRegex "\\<R=local_user\\>.*mail_spool defer"
        DSType "CounterInc"
        Type "counter"
        Instance "local_user"
      </Match>
    </File>
  </Plugin>

The config consists of one or more B<File> blocks, each of which configures one
logfile to parse. Within each B<File> block, there are one or more B<Match>
blocks, which configure a regular expression to search for.

The B<Instance> option in the B<File> block may be used to set the plugin
instance. So in the above example the plugin name C<tail-foo> would be used.
This plugin instance is for all B<Match> blocks that B<follow> it, until the
next B<Instance> option. This way you can extract several plugin instances from
one logfile, handy when parsing syslog and the like.

Each B<Match> block has the following options to describe how the match should
be performed:

=over 4

=item B<Regex> I<regex>

Sets the regular expression to use for matching against a line. The first
subexpression has to match something that can be turned into a number by
L<strtoll(3)> or L<strtod(3)>, depending on the value of C<CounterAdd>, see
below. Because B<extended> regular expressions are used, you do not need to use
backslashes for subexpressions! If in doubt, please consult L<regex(7)>. Due to
collectd's config parsing you need to escape backslashes, though. So if you
want to match literal parentheses you need to do the following:

  Regex "SPAM \\(Score: (-?[0-9]+\\.[0-9]+)\\)"

=item B<ExcludeRegex> I<regex>

Sets an optional regular expression to use for excluding lines from the match.
An example which excludes all connections from localhost from the match:

  ExcludeRegex "127\\.0\\.0\\.1"

=item B<DSType> I<Type>

Sets how the values are cumulated. I<Type> is one of:

=over 4

=item B<GaugeAverage>

Calculate the average.

=item B<GaugeMin>

Use the smallest number only.

=item B<GaugeMax>

Use the greatest number only.

=item B<GaugeLast>

Use the last number found.

=item B<CounterSet>

=item B<DeriveSet>

=item B<AbsoluteSet>

The matched number is a counter. Simply I<sets> the internal counter to this
value. Variants exist for C<COUNTER>, C<DERIVE>, and C<ABSOLUTE> data sources.

=item B<CounterAdd>

=item B<DeriveAdd>

Add the matched value to the internal counter. In case of B<DeriveAdd>, the
matched number may be negative, which will effectively subtract from the
internal counter.

=item B<CounterInc>

=item B<DeriveInc>

Increase the internal counter by one. These B<DSType> are the only ones that do
not use the matched subexpression, but simply count the number of matched
lines. Thus, you may use a regular expression without submatch in this case.

=back

As you'd expect the B<Gauge*> types interpret the submatch as a floating point
number, using L<strtod(3)>. The B<Counter*> and B<AbsoluteSet> types interpret
the submatch as an unsigned integer using L<strtoull(3)>. The B<Derive*> types
interpret the submatch as a signed integer using L<strtoll(3)>. B<CounterInc>
and B<DeriveInc> do not use the submatch at all and it may be omitted in this
case.

=item B<Type> I<Type>

Sets the type used to dispatch this value. Detailed information about types and
their configuration can be found in L<types.db(5)>.

=item B<Instance> I<TypeInstance>

This optional setting sets the type instance to use.

=back

=head2 Plugin C<tail_csv>

The I<tail_csv plugin> reads files in the CSV format, e.g. the statistics file
written by I<Snort>.

B<Synopsis:>

 <Plugin "tail_csv">
   <Metric "snort-dropped">
       Type "percent"
       Instance "dropped"
       Index 1
   </Metric>
   <File "/var/log/snort/snort.stats">
       Instance "snort-eth0"
       Interval 600
       Collect "snort-dropped"
   </File>
 </Plugin>

The configuration consists of one or more B<Metric> blocks that define an index
into the line of the CSV file and how this value is mapped to I<collectd's>
internal representation. These are followed by one or more B<Instance> blocks
which configure which file to read, in which interval and which metrics to
extract.

=over 4

=item E<lt>B<Metric> I<Name>E<gt>

The B<Metric> block configures a new metric to be extracted from the statistics
file and how it is mapped on I<collectd's> data model. The string I<Name> is
only used inside the B<Instance> blocks to refer to this block, so you can use
one B<Metric> block for multiple CSV files.

=over 4

=item B<Type> I<Type>

Configures which I<Type> to use when dispatching this metric. Types are defined
in the L<types.db(5)> file, see the appropriate manual page for more
information on specifying types. Only types with a single I<data source> are
supported by the I<tail_csv plugin>. The information whether the value is an
absolute value (i.e. a C<GAUGE>) or a rate (i.e. a C<DERIVE>) is taken from the
I<Type's> definition.

=item B<Instance> I<TypeInstance>

If set, I<TypeInstance> is used to populate the type instance field of the
created value lists. Otherwise, no type instance is used.

=item B<ValueFrom> I<Index>

Configure to read the value from the field with the zero-based index I<Index>.
If the value is parsed as signed integer, unsigned integer or double depends on
the B<Type> setting, see above.

=back

=item E<lt>B<File> I<Path>E<gt>

Each B<File> block represents one CSV file to read. There must be at least one
I<File> block but there can be multiple if you have multiple CSV files.

=over 4

=item B<Instance> I<PluginInstance>

Sets the I<plugin instance> used when dispatching the values.

=item B<Collect> I<Metric>

Specifies which I<Metric> to collect. This option must be specified at least
once, and you can use this option multiple times to specify more than one
metric to be extracted from this statistic file.

=item B<Interval> I<Seconds>

Configures the interval in which to read values from this instance / file.
Defaults to the plugin's default interval.

=item B<TimeFrom> I<Index>

Rather than using the local time when dispatching a value, read the timestamp
from the field with the zero-based index I<Index>. The value is interpreted as
seconds since epoch. The value is parsed as a double and may be factional.

=back

=back

=head2 Plugin C<teamspeak2>

The C<teamspeak2 plugin> connects to the query port of a teamspeak2 server and
polls interesting global and virtual server data. The plugin can query only one
physical server but unlimited virtual servers. You can use the following
options to configure it:

=over 4

=item B<Host> I<hostname/ip>

The hostname or ip which identifies the physical server.
Default: 127.0.0.1

=item B<Port> I<port>

The query port of the physical server. This needs to be a string.
Default: "51234"

=item B<Server> I<port>

This option has to be added once for every virtual server the plugin should
query. If you want to query the virtual server on port 8767 this is what the
option would look like:

  Server "8767"

This option, although numeric, needs to be a string, i.E<nbsp>e. you B<must>
use quotes around it! If no such statement is given only global information
will be collected.

=back

=head2 Plugin C<ted>

The I<TED> plugin connects to a device of "The Energy Detective", a device to
measure power consumption. These devices are usually connected to a serial
(RS232) or USB port. The plugin opens a configured device and tries to read the
current energy readings. For more information on TED, visit
L<http://www.theenergydetective.com/>.

Available configuration options:

=over 4

=item B<Device> I<Path>

Path to the device on which TED is connected. collectd will need read and write
permissions on that file.

Default: B</dev/ttyUSB0>

=item B<Retries> I<Num>

Apparently reading from TED is not that reliable. You can therefore configure a
number of retries here. You only configure the I<retries> here, to if you
specify zero, one reading will be performed (but no retries if that fails); if
you specify three, a maximum of four readings are performed. Negative values
are illegal.

Default: B<0>

=back

=head2 Plugin C<tcpconns>

The C<tcpconns plugin> counts the number of currently established TCP
connections based on the local port and/or the remote port. Since there may be
a lot of connections the default if to count all connections with a local port,
for which a listening socket is opened. You can use the following options to
fine-tune the ports you are interested in:

=over 4

=item B<ListeningPorts> I<true>|I<false>

If this option is set to I<true>, statistics for all local ports for which a
listening socket exists are collected. The default depends on B<LocalPort> and
B<RemotePort> (see below): If no port at all is specifically selected, the
default is to collect listening ports. If specific ports (no matter if local or
remote ports) are selected, this option defaults to I<false>, i.E<nbsp>e. only
the selected ports will be collected unless this option is set to I<true>
specifically.

=item B<LocalPort> I<Port>

Count the connections to a specific local port. This can be used to see how
many connections are handled by a specific daemon, e.E<nbsp>g. the mailserver.
You have to specify the port in numeric form, so for the mailserver example
you'd need to set B<25>.

=item B<RemotePort> I<Port>

Count the connections to a specific remote port. This is useful to see how
much a remote service is used. This is most useful if you want to know how many
connections a local service has opened to remote services, e.E<nbsp>g. how many
connections a mail server or news server has to other mail or news servers, or
how many connections a web proxy holds to web servers. You have to give the
port in numeric form.

=back

=head2 Plugin C<thermal>

=over 4

=item B<ForceUseProcfs> I<true>|I<false>

By default, the I<Thermal plugin> tries to read the statistics from the Linux
C<sysfs> interface. If that is not available, the plugin falls back to the
C<procfs> interface. By setting this option to I<true>, you can force the
plugin to use the latter. This option defaults to I<false>.

=item B<Device> I<Device>

Selects the name of the thermal device that you want to collect or ignore,
depending on the value of the B<IgnoreSelected> option. This option may be
used multiple times to specify a list of devices.

=item B<IgnoreSelected> I<true>|I<false>

Invert the selection: If set to true, all devices B<except> the ones that
match the device names specified by the B<Device> option are collected. By
default only selected devices are collected if a selection is made. If no
selection is configured at all, B<all> devices are selected.

=back

=head2 Plugin C<threshold>

The I<Threshold plugin> checks values collected or received by I<collectd>
against a configurable I<threshold> and issues I<notifications> if values are
out of bounds.

Documentation for this plugin is available in the L<collectd-threshold(5)>
manual page.

=head2 Plugin C<tokyotyrant>

The I<TokyoTyrant plugin> connects to a TokyoTyrant server and collects a
couple metrics: number of records, and database size on disk.

=over 4

=item B<Host> I<Hostname/IP>

The hostname or ip which identifies the server.
Default: B<127.0.0.1>

=item B<Port> I<Service/Port>

The query port of the server. This needs to be a string, even if the port is
given in its numeric form.
Default: B<1978>

=back

=head2 Plugin C<unixsock>

=over 4

=item B<SocketFile> I<Path>

Sets the socket-file which is to be created.

=item B<SocketGroup> I<Group>

If running as root change the group of the UNIX-socket after it has been
created. Defaults to B<collectd>.

=item B<SocketPerms> I<Permissions>

Change the file permissions of the UNIX-socket after it has been created. The
permissions must be given as a numeric, octal value as you would pass to
L<chmod(1)>. Defaults to B<0770>.

=item B<DeleteSocket> B<false>|B<true>

If set to B<true>, delete the socket file before calling L<bind(2)>, if a file
with the given name already exists. If I<collectd> crashes a socket file may be
left over, preventing the daemon from opening a new socket when restarted.
Since this is potentially dangerous, this defaults to B<false>.

=back

=head2 Plugin C<uuid>

This plugin, if loaded, causes the Hostname to be taken from the machine's
UUID. The UUID is a universally unique designation for the machine, usually
taken from the machine's BIOS. This is most useful if the machine is running in
a virtual environment such as Xen, in which case the UUID is preserved across
shutdowns and migration.

The following methods are used to find the machine's UUID, in order:

=over 4

=item

Check I</etc/uuid> (or I<UUIDFile>).

=item

Check for UUID from HAL (L<http://www.freedesktop.org/wiki/Software/hal>) if
present.

=item

Check for UUID from C<dmidecode> / SMBIOS.

=item

Check for UUID from Xen hypervisor.

=back

If no UUID can be found then the hostname is not modified.

=over 4

=item B<UUIDFile> I<Path>

Take the UUID from the given file (default I</etc/uuid>).

=back

=head2 Plugin C<varnish>

The I<varnish plugin> collects information about Varnish, an HTTP accelerator.

Synopsis:

 <Plugin "varnish">
   <Instance "example">
     CollectCache       true
     CollectConnections true
     CollectBackend     true
     CollectSHM         true
     CollectESI         false
     CollectFetch       false
     CollectHCB         false
     CollectSMA         false
     CollectSMS         false
     CollectSM          false
     CollectTotals      false
     CollectWorkers     false
   </Instance>
 </Plugin>

The configuration consists of one or more E<lt>B<Instance>E<nbsp>I<Name>E<gt>
blocks. I<Name> is the parameter passed to "varnishd -n". If left empty, it
will collectd statistics from the default "varnishd" instance (this should work
fine in most cases).

Inside each E<lt>B<Instance>E<gt> blocks, the following options are recognized:

=over 4

=item B<CollectCache> B<true>|B<false>

Cache hits and misses. True by default.

=item B<CollectConnections> B<true>|B<false>

Number of client connections received, accepted and dropped. True by default.

=item B<CollectBackend> B<true>|B<false>

Back-end connection statistics, such as successful, reused,
and closed connections. True by default.

=item B<CollectSHM> B<true>|B<false>

Statistics about the shared memory log, a memory region to store
log messages which is flushed to disk when full. True by default.

=item B<CollectBan> B<true>|B<false>

Statistics about ban operations, such as number of bans added, retired, and
number of objects tested against ban operations. Only available with Varnish
3.x. False by default.

=item B<CollectDirectorDNS> B<true>|B<false>

DNS director lookup cache statistics. Only available with Varnish 3.x. False by
default.

=item B<CollectESI> B<true>|B<false>

Edge Side Includes (ESI) parse statistics. False by default.

=item B<CollectFetch> B<true>|B<false>

Statistics about fetches (HTTP requests sent to the backend). False by default.

=item B<CollectHCB> B<true>|B<false>

Inserts and look-ups in the crit bit tree based hash. Look-ups are
divided into locked and unlocked look-ups. False by default.

=item B<CollectObjects> B<true>|B<false>

Statistics on cached objects: number of objects expired, nuked (prematurely
expired), saved, moved, etc. False by default.

=item B<CollectPurge> B<true>|B<false>

Statistics about purge operations, such as number of purges added, retired, and
number of objects tested against purge operations. Only available with Varnish
2.x. False by default.

=item B<CollectSession> B<true>|B<false>

Client session statistics. Number of past and current sessions, session herd and
linger counters, etc. False by default.

=item B<CollectSMA> B<true>|B<false>

malloc or umem (umem_alloc(3MALLOC) based) storage statistics. The umem storage
component is Solaris specific. Only available with Varnish 2.x. False by
default.

=item B<CollectSMS> B<true>|B<false>

synth (synthetic content) storage statistics. This storage
component is used internally only. False by default.

=item B<CollectSM> B<true>|B<false>

file (memory mapped file) storage statistics. Only available with Varnish 2.x.
False by default.

=item B<CollectStruct> B<true>|B<false>

Current varnish internal state statistics. Number of current sessions, objects
in cache store, open connections to backends (with Varnish 2.x), etc. False by
default.

=item B<CollectTotals> B<true>|B<false>

Collects overview counters, such as the number of sessions created,
the number of requests and bytes transferred. False by default.

=item B<CollectUptime> B<true>|B<false>

Varnish uptime. False by default.

=item B<CollectVCL> B<true>|B<false>

Number of total (available + discarded) VCL (config files). False by default.

=item B<CollectWorkers> B<true>|B<false>

Collect statistics about worker threads. False by default.

=back

=head2 Plugin C<vmem>

The C<vmem> plugin collects information about the usage of virtual memory.
Since the statistics provided by the Linux kernel are very detailed, they are
collected very detailed. However, to get all the details, you have to switch
them on manually. Most people just want an overview over, such as the number of
pages read from swap space.

=over 4

=item B<Verbose> B<true>|B<false>

Enables verbose collection of information. This will start collecting page
"actions", e.E<nbsp>g. page allocations, (de)activations, steals and so on.
Part of these statistics are collected on a "per zone" basis.

=back

=head2 Plugin C<vserver>

This plugin doesn't have any options. B<VServer> support is only available for
Linux. It cannot yet be found in a vanilla kernel, though. To make use of this
plugin you need a kernel that has B<VServer> support built in, i.E<nbsp>e. you
need to apply the patches and compile your own kernel, which will then provide
the F</proc/virtual> filesystem that is required by this plugin.

The B<VServer> homepage can be found at L<http://linux-vserver.org/>.

B<Note>: The traffic collected by this plugin accounts for the amount of
traffic passing a socket which might be a lot less than the actual on-wire
traffic (e.E<nbsp>g. due to headers and retransmission). If you want to
collect on-wire traffic you could, for example, use the logging facilities of
iptables to feed data for the guest IPs into the iptables plugin.

=head2 Plugin C<write_graphite>

The C<write_graphite> plugin writes data to I<Graphite>, an open-source metrics
storage and graphing project. The plugin connects to I<Carbon>, the data layer
of I<Graphite>, via I<TCP> or I<UDP> and sends data via the "line based"
protocol (per default using portE<nbsp>2003). The data will be sent in blocks
of at most 1428 bytes to minimize the number of network packets.

Synopsis:

 <Plugin write_graphite>
   <Node "example">
     Host "localhost"
     Port "2003"
     Protocol "tcp"
     LogSendErrors true
     Prefix "collectd"
   </Node>
 </Plugin>

The configuration consists of one or more E<lt>B<Node>E<nbsp>I<Name>E<gt>
blocks. Inside the B<Node> blocks, the following options are recognized:

=over 4

=item B<Host> I<Address>

Hostname or address to connect to. Defaults to C<localhost>.

=item B<Port> I<Service>

Service name or port number to connect to. Defaults to C<2003>.

=item B<Protocol> I<String>

Protocol to use when connecting to I<Graphite>. Defaults to C<tcp>.

=item B<LogSendErrors> B<false>|B<true>

If set to B<true> (the default), logs errors when sending data to I<Graphite>.
If set to B<false>, it will not log the errors. This is especially useful when
using Protocol UDP since many times we want to use the "fire-and-forget"
approach and logging errors fills syslog with unneeded messages.

=item B<Prefix> I<String>

When set, I<String> is added in front of the host name. Dots and whitespace are
I<not> escaped in this string (see B<EscapeCharacter> below).

=item B<Postfix> I<String>

When set, I<String> is appended to the host name. Dots and whitespace are
I<not> escaped in this string (see B<EscapeCharacter> below).

=item B<EscapeCharacter> I<Char>

I<Carbon> uses the dot (C<.>) as escape character and doesn't allow whitespace
in the identifier. The B<EscapeCharacter> option determines which character
dots, whitespace and control characters are replaced with. Defaults to
underscore (C<_>).

=item B<StoreRates> B<false>|B<true>

If set to B<true> (the default), convert counter values to rates. If set to
B<false> counter values are stored as is, i.E<nbsp>e. as an increasing integer
number.

=item B<SeparateInstances> B<false>|B<true>

If set to B<true>, the plugin instance and type instance will be in their own
path component, for example C<host.cpu.0.cpu.idle>. If set to B<false> (the
default), the plugin and plugin instance (and likewise the type and type
instance) are put into one component, for example C<host.cpu-0.cpu-idle>.

=item B<AlwaysAppendDS> B<false>|B<true>

If set the B<true>, append the name of the I<Data Source> (DS) to the "metric"
identifier. If set to B<false> (the default), this is only done when there is
more than one DS.

=back

=head2 Plugin C<write_mongodb>

The I<write_mongodb plugin> will send values to I<MongoDB>, a schema-less
NoSQL database.

B<Synopsis:>

 <Plugin "write_mongodb">
   <Node "default">
     Host "localhost"
     Port "27017"
     Timeout 1000
     StoreRates true
   </Node>
 </Plugin>

The plugin can send values to multiple instances of I<MongoDB> by specifying
one B<Node> block for each instance. Within the B<Node> blocks, the following
options are available:

=over 4

=item B<Host> I<Address>

Hostname or address to connect to. Defaults to C<localhost>.

=item B<Port> I<Service>

Service name or port number to connect to. Defaults to C<27017>.

=item B<Timeout> I<Timeout>

Set the timeout for each operation on I<MongoDB> to I<Timeout> milliseconds.
Setting this option to zero means no timeout, which is the default.

=item B<StoreRates> B<false>|B<true>

If set to B<true> (the default), convert counter values to rates. If set to
B<false> counter values are stored as is, i.e. as an increasing integer
number.

=item B<Database> I<Database>

=item B<User> I<User>

=item B<Password> I<Password>

Sets the information used when authenticating to a I<MongoDB> database. The
fields are optional (in which case no authentication is attempted), but if you
want to use authentication all three fields must be set.

=back

=head2 Plugin C<write_http>

This output plugin submits values to an http server by POST them using the
PUTVAL plain-text protocol. Each destination you want to post data to needs to
have one B<URL> block, within which the destination can be configured further,
for example by specifying authentication data.

Synopsis:

 <Plugin "write_http">
   <URL "http://example.com/post-collectd">
     User "collectd"
     Password "weCh3ik0"
   </URL>
 </Plugin>

B<URL> blocks need one string argument which is used as the URL to which data
is posted. The following options are understood within B<URL> blocks.

=over 4

=item B<User> I<Username>

Optional user name needed for authentication.

=item B<Password> I<Password>

Optional password needed for authentication.

=item B<VerifyPeer> B<true>|B<false>

Enable or disable peer SSL certificate verification. See
L<http://curl.haxx.se/docs/sslcerts.html> for details. Enabled by default.

=item B<VerifyHost> B<true|false>

Enable or disable peer host name verification. If enabled, the plugin checks if
the C<Common Name> or a C<Subject Alternate Name> field of the SSL certificate
matches the host name provided by the B<URL> option. If this identity check
fails, the connection is aborted. Obviously, only works when connecting to a
SSL enabled server. Enabled by default.

=item B<CACert> I<File>

File that holds one or more SSL certificates. If you want to use HTTPS you will
possibly need this option. What CA certificates come bundled with C<libcurl>
and are checked by default depends on the distribution you use.

=item B<Format> B<Command>|B<JSON>

Format of the output to generate. If set to B<Command>, will create output that
is understood by the I<Exec> and I<UnixSock> plugins. When set to B<JSON>, will
create output in the I<JavaScript Object Notation> (JSON).

Defaults to B<Command>.

=item B<StoreRates> B<true|false>

If set to B<true>, convert counter values to rates. If set to B<false> (the
default) counter values are stored as is, i.E<nbsp>e. as an increasing integer
number.

=back

=head2 Plugin C<write_riemann>

The I<write_riemann plugin> will send values to I<Riemann>, a powerfull stream
aggregation and monitoring system. The plugin sends I<Protobuf> encoded data to
I<Riemann> using UDP packets.

Synopsis:

 <Plugin "write_riemann">
   <Node "example">
     Host "localhost"
     Port "5555"
     Protocol UDP
     StoreRates true
     AlwaysAppendDS false
     TTLFactor 2.0
   </Node>
   Tag "foobar"
   Attribute "foo" "bar"
 </Plugin>

The following options are understood by the I<write_riemann plugin>:

=over 4

=item E<lt>B<Node> I<Name>E<gt>

The plugin's configuration consists of one or more B<Node> blocks. Each block
is given a unique I<Name> and specifies one connection to an instance of
I<Riemann>. Indise the B<Node> block, the following per-connection options are
understood:

=over 4

=item B<Host> I<Address>

Hostname or address to connect to. Defaults to C<localhost>.

=item B<Port> I<Service>

Service name or port number to connect to. Defaults to C<5555>.

=item B<Protocol> B<UDP>|B<TCP>

Specify the protocol to use when communicating with I<Riemann>. Defaults to
B<UDP>.

=item B<StoreRates> B<true>|B<false>

If set to B<true> (the default), convert counter values to rates. If set to
B<false> counter values are stored as is, i.e. as an increasing integer number.

This will be reflected in the C<ds_type> tag: If B<StoreRates> is enabled,
converted values will have "rate" appended to the data source type, e.g.
C<ds_type:derive:rate>.

=item B<AlwaysAppendDS> B<false>|B<true>

If set the B<true>, append the name of the I<Data Source> (DS) to the
"service", i.e. the field that, together with the "host" field, uniquely
identifies a metric in I<Riemann>. If set to B<false> (the default), this is
only done when there is more than one DS.

=item B<TTLFactor> I<Factor>

I<Riemann> events have a I<Time to Live> (TTL) which specifies how long each
event is considered active. I<collectd> populates this field based on the
metrics interval setting. This setting controls the factor with which the
interval is multiplied to set the TTL. The default value is B<2.0>. Unless you
know exactly what you're doing, you should only increase this setting from its
default value.

=back

=item B<Tag> I<String>

Add the given string as an additional tag to the metric being sent to
I<Riemann>.

=item B<Attribute> I<String> I<String>

Consider the two given strings to be the key and value of an additional
attribute for each metric being sent out to I<Riemann>.

=back

=head1 THRESHOLD CONFIGURATION

Starting with version C<4.3.0> collectd has support for B<monitoring>. By that
we mean that the values are not only stored or sent somewhere, but that they
are judged and, if a problem is recognized, acted upon. The only action
collectd takes itself is to generate and dispatch a "notification". Plugins can
register to receive notifications and perform appropriate further actions.

Since systems and what you expect them to do differ a lot, you can configure
B<thresholds> for your values freely. This gives you a lot of flexibility but
also a lot of responsibility.

Every time a value is out of range a notification is dispatched. This means
that the idle percentage of your CPU needs to be less then the configured
threshold only once for a notification to be generated. There's no such thing
as a moving average or similar - at least not now.

Also, all values that match a threshold are considered to be relevant or
"interesting". As a consequence collectd will issue a notification if they are
not received for B<Timeout> iterations. The B<Timeout> configuration option is
explained in section L<"GLOBAL OPTIONS">. If, for example, B<Timeout> is set to
"2" (the default) and some hosts sends it's CPU statistics to the server every
60 seconds, a notification will be dispatched after about 120 seconds. It may
take a little longer because the timeout is checked only once each B<Interval>
on the server.

When a value comes within range again or is received after it was missing, an
"OKAY-notification" is dispatched.

Here is a configuration example to get you started. Read below for more
information.

 <Plugin threshold>
   <Type "foo">
     WarningMin    0.00
     WarningMax 1000.00
     FailureMin    0.00
     FailureMax 1200.00
     Invert false
     Instance "bar"
   </Type>

   <Plugin "interface">
     Instance "eth0"
     <Type "if_octets">
       FailureMax 10000000
       DataSource "rx"
     </Type>
   </Plugin>

   <Host "hostname">
     <Type "cpu">
       Instance "idle"
       FailureMin 10
     </Type>

     <Plugin "memory">
       <Type "memory">
         Instance "cached"
         WarningMin 100000000
       </Type>
     </Plugin>
   </Host>
 </Plugin>

There are basically two types of configuration statements: The C<Host>,
C<Plugin>, and C<Type> blocks select the value for which a threshold should be
configured. The C<Plugin> and C<Type> blocks may be specified further using the
C<Instance> option. You can combine the block by nesting the blocks, though
they must be nested in the above order, i.E<nbsp>e. C<Host> may contain either
C<Plugin> and C<Type> blocks, C<Plugin> may only contain C<Type> blocks and
C<Type> may not contain other blocks. If multiple blocks apply to the same
value the most specific block is used.

The other statements specify the threshold to configure. They B<must> be
included in a C<Type> block. Currently the following statements are recognized:

=over 4

=item B<FailureMax> I<Value>

=item B<WarningMax> I<Value>

Sets the upper bound of acceptable values. If unset defaults to positive
infinity. If a value is greater than B<FailureMax> a B<FAILURE> notification
will be created. If the value is greater than B<WarningMax> but less than (or
equal to) B<FailureMax> a B<WARNING> notification will be created.

=item B<FailureMin> I<Value>

=item B<WarningMin> I<Value>

Sets the lower bound of acceptable values. If unset defaults to negative
infinity. If a value is less than B<FailureMin> a B<FAILURE> notification will
be created. If the value is less than B<WarningMin> but greater than (or equal
to) B<FailureMin> a B<WARNING> notification will be created.

=item B<DataSource> I<DSName>

Some data sets have more than one "data source". Interesting examples are the
C<if_octets> data set, which has received (C<rx>) and sent (C<tx>) bytes and
the C<disk_ops> data set, which holds C<read> and C<write> operations. The
system load data set, C<load>, even has three data sources: C<shortterm>,
C<midterm>, and C<longterm>.

Normally, all data sources are checked against a configured threshold. If this
is undesirable, or if you want to specify different limits for each data
source, you can use the B<DataSource> option to have a threshold apply only to
one data source.

=item B<Invert> B<true>|B<false>

If set to B<true> the range of acceptable values is inverted, i.E<nbsp>e.
values between B<FailureMin> and B<FailureMax> (B<WarningMin> and
B<WarningMax>) are not okay. Defaults to B<false>.

=item B<Persist> B<true>|B<false>

Sets how often notifications are generated. If set to B<true> one notification
will be generated for each value that is out of the acceptable range. If set to
B<false> (the default) then a notification is only generated if a value is out
of range but the previous value was okay.

This applies to missing values, too: If set to B<true> a notification about a
missing value is generated once every B<Interval> seconds. If set to B<false>
only one such notification is generated until the value appears again.

=item B<Percentage> B<true>|B<false>

If set to B<true>, the minimum and maximum values given are interpreted as
percentage value, relative to the other data sources. This is helpful for
example for the "df" type, where you may want to issue a warning when less than
5E<nbsp>% of the total space is available. Defaults to B<false>.

=item B<Hits> I<Number>

Delay creating the notification until the threshold has been passed I<Number>
times. When a notification has been generated, or when a subsequent value is
inside the threshold, the counter is reset. If, for example, a value is
collected once every 10E<nbsp>seconds and B<Hits> is set to 3, a notification
will be dispatched at most once every 30E<nbsp>seconds.

This is useful when short bursts are not a problem. If, for example, 100% CPU
usage for up to a minute is normal (and data is collected every
10E<nbsp>seconds), you could set B<Hits> to B<6> to account for this.

=item B<Hysteresis> I<Number>

When set to non-zero, a hysteresis value is applied when checking minimum and
maximum bounds. This is useful for values that increase slowly and fluctuate a
bit while doing so. When these values come close to the threshold, they may
"flap", i.e. switch between failure / warning case and okay case repeatedly.

If, for example, the threshold is configures as

  WarningMax 100.0
  Hysteresis 1.0

then a I<Warning> notification is created when the value exceeds I<101> and the
corresponding I<Okay> notification is only created once the value falls below
I<99>, thus avoiding the "flapping".

=back

=head1 FILTER CONFIGURATION

Starting with collectd 4.6 there is a powerful filtering infrastructure
implemented in the daemon. The concept has mostly been copied from
I<ip_tables>, the packet filter infrastructure for Linux. We'll use a similar
terminology, so that users that are familiar with iptables feel right at home.

=head2 Terminology

The following are the terms used in the remainder of the filter configuration
documentation. For an ASCII-art schema of the mechanism, see
L<"General structure"> below.

=over 4

=item B<Match>

A I<match> is a criteria to select specific values. Examples are, of course, the
name of the value or it's current value.

Matches are implemented in plugins which you have to load prior to using the
match. The name of such plugins starts with the "match_" prefix.

=item B<Target>

A I<target> is some action that is to be performed with data. Such actions
could, for example, be to change part of the value's identifier or to ignore
the value completely.

Some of these targets are built into the daemon, see L<"Built-in targets">
below. Other targets are implemented in plugins which you have to load prior to
using the target. The name of such plugins starts with the "target_" prefix.

=item B<Rule>

The combination of any number of matches and at least one target is called a
I<rule>. The target actions will be performed for all values for which B<all>
matches apply. If the rule does not have any matches associated with it, the
target action will be performed for all values.

=item B<Chain>

A I<chain> is a list of rules and possibly default targets. The rules are tried
in order and if one matches, the associated target will be called. If a value
is handled by a rule, it depends on the target whether or not any subsequent
rules are considered or if traversal of the chain is aborted, see
L<"Flow control"> below. After all rules have been checked, the default targets
will be executed.

=back

=head2 General structure

The following shows the resulting structure:

 +---------+
 ! Chain   !
 +---------+
      !
      V
 +---------+  +---------+  +---------+  +---------+
 ! Rule    !->! Match   !->! Match   !->! Target  !
 +---------+  +---------+  +---------+  +---------+
      !
      V
 +---------+  +---------+  +---------+
 ! Rule    !->! Target  !->! Target  !
 +---------+  +---------+  +---------+
      !
      V
      :
      :
      !
      V
 +---------+  +---------+  +---------+
 ! Rule    !->! Match   !->! Target  !
 +---------+  +---------+  +---------+
      !
      V
 +---------+
 ! Default !
 ! Target  !
 +---------+

=head2 Flow control

There are four ways to control which way a value takes through the filter
mechanism:

=over 4

=item B<jump>

The built-in B<jump> target can be used to "call" another chain, i.E<nbsp>e.
process the value with another chain. When the called chain finishes, usually
the next target or rule after the jump is executed.

=item B<stop>

The stop condition, signaled for example by the built-in target B<stop>, causes
all processing of the value to be stopped immediately.

=item B<return>

Causes processing in the current chain to be aborted, but processing of the
value generally will continue. This means that if the chain was called via
B<Jump>, the next target or rule after the jump will be executed. If the chain
was not called by another chain, control will be returned to the daemon and it
may pass the value to another chain.

=item B<continue>

Most targets will signal the B<continue> condition, meaning that processing
should continue normally. There is no special built-in target for this
condition.

=back

=head2 Synopsis

The configuration reflects this structure directly:

 PostCacheChain "PostCache"
 <Chain "PostCache">
   <Rule "ignore_mysql_show">
     <Match "regex">
       Plugin "^mysql$"
       Type "^mysql_command$"
       TypeInstance "^show_"
     </Match>
     <Target "stop">
     </Target>
   </Rule>
   <Target "write">
     Plugin "rrdtool"
   </Target>
 </Chain>

The above configuration example will ignore all values where the plugin field
is "mysql", the type is "mysql_command" and the type instance begins with
"show_". All other values will be sent to the C<rrdtool> write plugin via the
default target of the chain. Since this chain is run after the value has been
added to the cache, the MySQL C<show_*> command statistics will be available
via the C<unixsock> plugin.

=head2 List of configuration options

=over 4

=item B<PreCacheChain> I<ChainName>

=item B<PostCacheChain> I<ChainName>

Configure the name of the "pre-cache chain" and the "post-cache chain". The
argument is the name of a I<chain> that should be executed before and/or after
the values have been added to the cache.

To understand the implications, it's important you know what is going on inside
I<collectd>. The following diagram shows how values are passed from the
read-plugins to the write-plugins:

   +---------------+
   !  Read-Plugin  !
   +-------+-------+
           !
 + - - - - V - - - - +
 : +---------------+ :
 : !   Pre-Cache   ! :
 : !     Chain     ! :
 : +-------+-------+ :
 :         !         :
 :         V         :
 : +-------+-------+ :  +---------------+
 : !     Cache     !--->!  Value Cache  !
 : !     insert    ! :  +---+---+-------+
 : +-------+-------+ :      !   !
 :         !   ,------------'   !
 :         V   V     :          V
 : +-------+---+---+ :  +-------+-------+
 : !  Post-Cache   +--->! Write-Plugins !
 : !     Chain     ! :  +---------------+
 : +---------------+ :
 :                   :
 :  dispatch values  :
 + - - - - - - - - - +

After the values are passed from the "read" plugins to the dispatch functions,
the pre-cache chain is run first. The values are added to the internal cache
afterwards. The post-cache chain is run after the values have been added to the
cache. So why is it such a huge deal if chains are run before or after the
values have been added to this cache?

Targets that change the identifier of a value list should be executed before
the values are added to the cache, so that the name in the cache matches the
name that is used in the "write" plugins. The C<unixsock> plugin, too, uses
this cache to receive a list of all available values. If you change the
identifier after the value list has been added to the cache, this may easily
lead to confusion, but it's not forbidden of course.

The cache is also used to convert counter values to rates. These rates are, for
example, used by the C<value> match (see below). If you use the rate stored in
the cache B<before> the new value is added, you will use the old, B<previous>
rate. Write plugins may use this rate, too, see the C<csv> plugin, for example.
The C<unixsock> plugin uses these rates too, to implement the C<GETVAL>
command.

Last but not last, the B<stop> target makes a difference: If the pre-cache
chain returns the stop condition, the value will not be added to the cache and
the post-cache chain will not be run.

=item B<Chain> I<Name>

Adds a new chain with a certain name. This name can be used to refer to a
specific chain, for example to jump to it.

Within the B<Chain> block, there can be B<Rule> blocks and B<Target> blocks.

=item B<Rule> [I<Name>]

Adds a new rule to the current chain. The name of the rule is optional and
currently has no meaning for the daemon.

Within the B<Rule> block, there may be any number of B<Match> blocks and there
must be at least one B<Target> block.

=item B<Match> I<Name>

Adds a match to a B<Rule> block. The name specifies what kind of match should
be performed. Available matches depend on the plugins that have been loaded.

The arguments inside the B<Match> block are passed to the plugin implementing
the match, so which arguments are valid here depends on the plugin being used.
If you do not need any to pass any arguments to a match, you can use the
shorter syntax:

 Match "foobar"

Which is equivalent to:

 <Match "foobar">
 </Match>

=item B<Target> I<Name>

Add a target to a rule or a default target to a chain. The name specifies what
kind of target is to be added. Which targets are available depends on the
plugins being loaded.

The arguments inside the B<Target> block are passed to the plugin implementing
the target, so which arguments are valid here depends on the plugin being used.
If you do not need any to pass any arguments to a target, you can use the
shorter syntax:

 Target "stop"

This is the same as writing:

 <Target "stop">
 </Target>

=back

=head2 Built-in targets

The following targets are built into the core daemon and therefore need no
plugins to be loaded:

=over 4

=item B<return>

Signals the "return" condition, see the L<"Flow control"> section above. This
causes the current chain to stop processing the value and returns control to
the calling chain. The calling chain will continue processing targets and rules
just after the B<jump> target (see below). This is very similar to the
B<RETURN> target of iptables, see L<iptables(8)>.

This target does not have any options.

Example:

 Target "return"

=item B<stop>

Signals the "stop" condition, see the L<"Flow control"> section above. This
causes processing of the value to be aborted immediately. This is similar to
the B<DROP> target of iptables, see L<iptables(8)>.

This target does not have any options.

Example:

 Target "stop"

=item B<write>

Sends the value to "write" plugins.

Available options:

=over 4

=item B<Plugin> I<Name>

Name of the write plugin to which the data should be sent. This option may be
given multiple times to send the data to more than one write plugin.

=back

If no plugin is explicitly specified, the values will be sent to all available
write plugins.

Example:

 <Target "write">
   Plugin "rrdtool"
 </Target>

=item B<jump>

Starts processing the rules of another chain, see L<"Flow control"> above. If
the end of that chain is reached, or a stop condition is encountered,
processing will continue right after the B<jump> target, i.E<nbsp>e. with the
next target or the next rule. This is similar to the B<-j> command line option
of iptables, see L<iptables(8)>.

Available options:

=over 4

=item B<Chain> I<Name>

Jumps to the chain I<Name>. This argument is required and may appear only once.

=back

Example:

 <Target "jump">
   Chain "foobar"
 </Target>

=back

=head2 Available matches

=over 4

=item B<regex>

Matches a value using regular expressions.

Available options:

=over 4

=item B<Host> I<Regex>

=item B<Plugin> I<Regex>

=item B<PluginInstance> I<Regex>

=item B<Type> I<Regex>

=item B<TypeInstance> I<Regex>

Match values where the given regular expressions match the various fields of
the identifier of a value. If multiple regular expressions are given, B<all>
regexen must match for a value to match.

=item B<Invert> B<false>|B<true>

When set to B<true>, the result of the match is inverted, i.e. all value lists
where all regular expressions apply are not matched, all other value lists are
matched. Defaults to B<false>.

=back

Example:

 <Match "regex">
   Host "customer[0-9]+"
   Plugin "^foobar$"
 </Match>

=item B<timediff>

Matches values that have a time which differs from the time on the server.

This match is mainly intended for servers that receive values over the
C<network> plugin and write them to disk using the C<rrdtool> plugin. RRDtool
is very sensitive to the timestamp used when updating the RRD files. In
particular, the time must be ever increasing. If a misbehaving client sends one
packet with a timestamp far in the future, all further packets with a correct
time will be ignored because of that one packet. What's worse, such corrupted
RRD files are hard to fix.

This match lets one match all values B<outside> a specified time range
(relative to the server's time), so you can use the B<stop> target (see below)
to ignore the value, for example.

Available options:

=over 4

=item B<Future> I<Seconds>

Matches all values that are I<ahead> of the server's time by I<Seconds> or more
seconds. Set to zero for no limit. Either B<Future> or B<Past> must be
non-zero.

=item B<Past> I<Seconds>

Matches all values that are I<behind> of the server's time by I<Seconds> or
more seconds. Set to zero for no limit. Either B<Future> or B<Past> must be
non-zero.

=back

Example:

 <Match "timediff">
   Future  300
   Past   3600
 </Match>

This example matches all values that are five minutes or more ahead of the
server or one hour (or more) lagging behind.

=item B<value>

Matches the actual value of data sources against given minimumE<nbsp>/ maximum
values. If a data-set consists of more than one data-source, all data-sources
must match the specified ranges for a positive match.

Available options:

=over 4

=item B<Min> I<Value>

Sets the smallest value which still results in a match. If unset, behaves like
negative infinity.

=item B<Max> I<Value>

Sets the largest value which still results in a match. If unset, behaves like
positive infinity.

=item B<Invert> B<true>|B<false>

Inverts the selection. If the B<Min> and B<Max> settings result in a match,
no-match is returned and vice versa. Please note that the B<Invert> setting
only effects how B<Min> and B<Max> are applied to a specific value. Especially
the B<DataSource> and B<Satisfy> settings (see below) are not inverted.

=item B<DataSource> I<DSName> [I<DSName> ...]

Select one or more of the data sources. If no data source is configured, all
data sources will be checked. If the type handled by the match does not have a
data source of the specified name(s), this will always result in no match
(independent of the B<Invert> setting).

=item B<Satisfy> B<Any>|B<All>

Specifies how checking with several data sources is performed. If set to
B<Any>, the match succeeds if one of the data sources is in the configured
range. If set to B<All> the match only succeeds if all data sources are within
the configured range. Default is B<All>.

Usually B<All> is used for positive matches, B<Any> is used for negative
matches. This means that with B<All> you usually check that all values are in a
"good" range, while with B<Any> you check if any value is within a "bad" range
(or outside the "good" range).

=back

Either B<Min> or B<Max>, but not both, may be unset.

Example:

 # Match all values smaller than or equal to 100. Matches only if all data
 # sources are below 100.
 <Match "value">
   Max 100
   Satisfy "All"
 </Match>
 
 # Match if the value of any data source is outside the range of 0 - 100.
 <Match "value">
   Min   0
   Max 100
   Invert true
   Satisfy "Any"
 </Match>

=item B<empty_counter>

Matches all values with one or more data sources of type B<COUNTER> and where
all counter values are zero. These counters usually I<never> increased since
they started existing (and are therefore uninteresting), or got reset recently
or overflowed and you had really, I<really> bad luck.

Please keep in mind that ignoring such counters can result in confusing
behavior: Counters which hardly ever increase will be zero for long periods of
time. If the counter is reset for some reason (machine or service restarted,
usually), the graph will be empty (NAN) for a long time. People may not
understand why.

=item B<hashed>

Calculates a hash value of the host name and matches values according to that
hash value. This makes it possible to divide all hosts into groups and match
only values that are in a specific group. The intended use is in load
balancing, where you want to handle only part of all data and leave the rest
for other servers.

The hashing function used tries to distribute the hosts evenly. First, it
calculates a 32E<nbsp>bit hash value using the characters of the hostname:

  hash_value = 0;
  for (i = 0; host[i] != 0; i++)
    hash_value = (hash_value * 251) + host[i];

The constant 251 is a prime number which is supposed to make this hash value
more random. The code then checks the group for this host according to the
I<Total> and I<Match> arguments:

  if ((hash_value % Total) == Match)
    matches;
  else
    does not match;

Please note that when you set I<Total> to two (i.E<nbsp>e. you have only two
groups), then the least significant bit of the hash value will be the XOR of
all least significant bits in the host name. One consequence is that when you
have two hosts, "server0.example.com" and "server1.example.com", where the host
name differs in one digit only and the digits differ by one, those hosts will
never end up in the same group.

Available options:

=over 4

=item B<Match> I<Match> I<Total>

Divide the data into I<Total> groups and match all hosts in group I<Match> as
described above. The groups are numbered from zero, i.E<nbsp>e. I<Match> must
be smaller than I<Total>. I<Total> must be at least one, although only values
greater than one really do make any sense.

You can repeat this option to match multiple groups, for example:

  Match 3 7
  Match 5 7

The above config will divide the data into seven groups and match groups three
and five. One use would be to keep every value on two hosts so that if one
fails the missing data can later be reconstructed from the second host.

=back

Example:

 # Operate on the pre-cache chain, so that ignored values are not even in the
 # global cache.
 <Chain "PreCache">
   <Rule>
     <Match "hashed">
       # Divide all received hosts in seven groups and accept all hosts in
       # group three.
       Match 3 7
     </Match>
     # If matched: Return and continue.
     Target "return"
   </Rule>
   # If not matched: Return and stop.
   Target "stop"
 </Chain>

=back

=head2 Available targets

=over 4

=item B<notification>

Creates and dispatches a notification.

Available options:

=over 4

=item B<Message> I<String>

This required option sets the message of the notification. The following
placeholders will be replaced by an appropriate value:

=over 4

=item B<%{host}>

=item B<%{plugin}>

=item B<%{plugin_instance}>

=item B<%{type}>

=item B<%{type_instance}>

These placeholders are replaced by the identifier field of the same name.

=item B<%{ds:>I<name>B<}>

These placeholders are replaced by a (hopefully) human readable representation
of the current rate of this data source. If you changed the instance name
(using the B<set> or B<replace> targets, see below), it may not be possible to
convert counter values to rates.

=back

Please note that these placeholders are B<case sensitive>!

=item B<Severity> B<"FAILURE">|B<"WARNING">|B<"OKAY">

Sets the severity of the message. If omitted, the severity B<"WARNING"> is
used.

=back

Example:

  <Target "notification">
    Message "Oops, the %{type_instance} temperature is currently %{ds:value}!"
    Severity "WARNING"
  </Target>

=item B<replace>

Replaces parts of the identifier using regular expressions.

Available options:

=over 4

=item B<Host> I<Regex> I<Replacement>

=item B<Plugin> I<Regex> I<Replacement>

=item B<PluginInstance> I<Regex> I<Replacement>

=item B<TypeInstance> I<Regex> I<Replacement>

Match the appropriate field with the given regular expression I<Regex>. If the
regular expression matches, that part that matches is replaced with
I<Replacement>. If multiple places of the input buffer match a given regular
expression, only the first occurrence will be replaced.

You can specify each option multiple times to use multiple regular expressions
one after another.

=back

Example:

 <Target "replace">
   # Replace "example.net" with "example.com"
   Host "\\<example.net\\>" "example.com"
 
   # Strip "www." from hostnames
   Host "\\<www\\." ""
 </Target>

=item B<set>

Sets part of the identifier of a value to a given string.

Available options:

=over 4

=item B<Host> I<String>

=item B<Plugin> I<String>

=item B<PluginInstance> I<String>

=item B<TypeInstance> I<String>

Set the appropriate field to the given string. The strings for plugin instance
and type instance may be empty, the strings for host and plugin may not be
empty. It's currently not possible to set the type of a value this way.

=back

Example:

 <Target "set">
   PluginInstance "coretemp"
   TypeInstance "core3"
 </Target>

=back

=head2 Backwards compatibility

If you use collectd with an old configuration, i.E<nbsp>e. one without a
B<Chain> block, it will behave as it used to. This is equivalent to the
following configuration:

 <Chain "PostCache">
   Target "write"
 </Chain>

If you specify a B<PostCacheChain>, the B<write> target will not be added
anywhere and you will have to make sure that it is called where appropriate. We
suggest to add the above snippet as default target to your "PostCache" chain.

=head2 Examples

Ignore all values, where the hostname does not contain a dot, i.E<nbsp>e. can't
be an FQDN.

 <Chain "PreCache">
   <Rule "no_fqdn">
     <Match "regex">
       Host "^[^\.]*$"
     </Match>
     Target "stop"
   </Rule>
   Target "write"
 </Chain>

=head1 SEE ALSO

L<collectd(1)>,
L<collectd-exec(5)>,
L<collectd-perl(5)>,
L<collectd-unixsock(5)>,
L<types.db(5)>,
L<hddtemp(8)>,
L<iptables(8)>,
L<kstat(3KSTAT)>,
L<mbmon(1)>,
L<psql(1)>,
L<regex(7)>,
L<rrdtool(1)>,
L<sensors(1)>

=head1 AUTHOR

Florian Forster E<lt>octo@verplant.orgE<gt>

=cut
